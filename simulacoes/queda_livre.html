<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Queda e Colisão Planetária (v3.0)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        /* ----------------------------------- */
        /* ESTILOS GERAIS E LAYOUT */
        /* ----------------------------------- */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f5;
            margin: 0;
            padding: 0; /* Remove padding para usar o máximo de espaço */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; 
            height: 100vh; 
            box-sizing: border-box; /* Inclui padding e border no tamanho total */
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .header-link {
            text-decoration: none; 
            color: #D2691E; 
            font-weight: bold; 
            margin-bottom: 10px;
        }
        
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px; 
            gap: 0px; 
            background-color: white;
            padding: 0; 
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            flex-grow: 1; 
            height: calc(100vh - 80px); /* Ocupa o restante da tela */
        }

        /* ----------------------------------- */
        /* CONTROLES (PAINEL ESQUERDO) */
        /* ----------------------------------- */
        .controls {
            width: 350px; 
            min-width: 350px;
            padding: 20px;
            border-right: 2px solid #ddd; 
            overflow-y: auto; 
        }

        .controls label, .controls button, .controls select, .controls input[type="number"], .controls input[type="range"] {
            display: block;
            margin-bottom: 15px;
            width: 100%;
        }

        /* ... estilos de botões e painéis ... */
        .controls label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }

        .controls select, .controls input[type="number"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
            font-size: 16px;
        }

        .controls button {
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-bottom: 10px;
        }

        #startButton, #addBallButton {
            background-color: #D2691E; 
            color: white;
        }

        #addBallButton {
            background-color: #4CAF50;
        }
        #addBallButton:hover {
            background-color: #45a049;
        }

        #startButton:hover {
            background-color: #c0601a;
            transform: translateY(-1px);
        }

        .data-panel {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        
        .data-panel h3 {
            margin-top: 0;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            color: #D2691E;
        }

        .kinematics-panel {
            margin-top: 20px;
            padding: 15px;
            border: 2px solid #f1c40f; 
            border-radius: 5px;
            background-color: #fffaf0; 
        }
        
        /* ----------------------------------- */
        /* ÁREA DE SIMULAÇÃO (PAINEL DIREITO) */
        /* ----------------------------------- */
        .simulation-area {
            flex-grow: 1;
            border-radius: 0 10px 10px 0; 
            overflow: hidden;
            position: relative;
            
            /* Malha Quadriculada Dinâmica */
            --grid-color: #bdc3c7;
            --grid-size: 50px; /* Valor base, será sobrescrito pelo JS */
            background-color: #ecf0f1; 
            background-image: 
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
        }

        .ball {
            position: absolute;
            border-radius: 50%;
            z-index: 20;
            transition: none; 
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            cursor: grab; 
        }
        
        .ball.dragging {
            cursor: grabbing;
            box-shadow: 0 0 20px 5px #f1c40f; 
        }
        
        .ball.selected {
            outline: 4px solid #f1c40f; 
            outline-offset: -4px;
        }

        #floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: #2c3e50;
            z-index: 10;
        }

    </style>
</head>
<body>
    <a href="index.html" class="header-link">
        <i class="fas fa-arrow-left"></i> Voltar para a Plataforma
    </a>
    
    <h1>Simulador de Queda Livre Planetária 2D</h1>

    <div class="container">
        <div class="controls">
            <h2>Configurações de Física</h2>
            
            <label for="gravitySelect">Gravidade (Corpo Celeste):</label>
            <select id="gravitySelect">
                </select>

            <label for="corInput">Elasticidade do Chão (COR 0.0-1.0):</label>
            <input type="number" id="corInput" value="0.85" min="0.0" max="1.0" step="0.05">

            <button id="startButton"><i class="fas fa-play"></i> Iniciar Simulação</button>
            
            <hr style="margin: 20px 0;">
            
            <h2>Adicionar Bola (Snapping de 5m)</h2>

            <label for="initialHeightInput">Altura Inicial (m):</label>
            <input type="number" id="initialHeightInput" value="50.0" min="5" step="5">

            <label for="massInput">Massa da Próxima Bola (kg):</label>
            <input type="number" id="massInput" value="1.0" min="0.1" step="0.1">

            <button id="addBallButton"><i class="fas fa-plus-circle"></i> Adicionar Bola</button>
            
            <button id="resetAllButton" style="background-color: #e74c3c;"><i class="fas fa-trash-alt"></i> Remover Todas</button>

            <div class="data-panel" style="margin-top: 20px;">
                <h3>Escala de Visualização (Zoom)</h3>
                <label for="zoomScaleInput">Ajuste o Nível de Zoom (Visual):</label>
                <input type="range" id="zoomScaleInput" min="0.5" max="2.0" value="1.0" step="0.1" style="width: 100%;">
                <p style="margin-top: 5px;">Zoom Atual: <span id="currentZoomScale">1.0x</span></p>
                <p>Malha: <span id="gridUnitMeter">5 metros</span></p>
            </div>


            <div class="data-panel">
                <h3>Status da Simulação</h3>
                <p>Gravidade (g): <span id="gValue">9.81 m/s²</span></p>
                <p>Total de Bolas: <span id="ballCount">0</span></p>
                <p>COR (Chão): <span id="corValue">0.85</span></p>
            </div>
            
            <div class="kinematics-panel">
                <h3>Dados Cinemáticos (Bola <span id="selectedBallId">-</span>)</h3>
                <p>Altura Inicial (H): <span id="initialHeightValue">N/A</span></p>
                <p>Altura Atual (h): <span id="currentHeightValue">N/A</span></p>
                <hr style="margin: 8px 0;">
                <p>Tempo de Queda (t): <span id="timeOfFallValue">0.00 s</span></p>
                <p>Velocidade Atual (v): <span id="currentVelocityValue">0.00 m/s</span></p>
                <p>Velocidade Teórica ($v_{teo}$): <span id="theoreticalVelocityValue">0.00 m/s</span></p>
            </div>

        </div>

        <div class="simulation-area">
            <div id="floor"></div>
        </div>
    </div>

    <script>
        // -----------------------------------
        // 1. CONFIGURAÇÕES FÍSICAS E DOM
        // -----------------------------------
        const GRAVITIES = {
            'Sol (g = 274.13)': 274.13,
            'Júpiter (g = 24.79)': 24.79,
            'Netuno (g = 11.15)': 11.15,
            'Saturno (g = 10.44)': 10.44,
            'Terra (g = 9.81)': 9.81,
            'Vênus (g = 8.87)': 8.87,
            'Urano (g = 8.69)': 8.69,
            'Marte (g = 3.72)': 3.72,
            'Mercúrio (g = 3.7)': 3.7,
            'Lua (g = 1.62)': 1.62,
            'Plutão (g = 0.62)': 0.62,
            'Simulação Espacial (g = 0.0)': 0.00
        };

        const simulationArea = document.querySelector('.simulation-area');
        const gravitySelect = document.getElementById('gravitySelect');
        const corInput = document.getElementById('corInput');
        const startButton = document.getElementById('startButton');
        const addBallButton = document.getElementById('addBallButton');
        const resetAllButton = document.getElementById('resetAllButton');
        const massInput = document.getElementById('massInput');
        
        // NOVOS ELEMENTOS DOM
        const initialHeightInput = document.getElementById('initialHeightInput');
        const zoomScaleInput = document.getElementById('zoomScaleInput');
        const currentZoomScaleOutput = document.getElementById('currentZoomScale');
        const gridUnitMeterOutput = document.getElementById('gridUnitMeter');


        const generalOutput = {
            g: document.getElementById('gValue'),
            cor: document.getElementById('corValue'),
            ballCount: document.getElementById('ballCount')
        };
        
        const kinematicsOutput = {
            id: document.getElementById('selectedBallId'),
            initialHeight: document.getElementById('initialHeightValue'),
            currentHeight: document.getElementById('currentHeightValue'),
            timeOfFall: document.getElementById('timeOfFallValue'),
            currentVelocity: document.getElementById('currentVelocityValue'),
            theoreticalVelocity: document.getElementById('theoreticalVelocityValue')
        };
        
        let SIM_WIDTH_PX = 0;
        let SIM_HEIGHT_PX = 0;
        const FLOOR_HEIGHT_PX = 5;

        // NOVAS CONSTANTES DE ESCALA
        const BASE_PIXELS_PER_METER = 100; // 100 pixels por metro na escala 1.0x
        const GRID_UNIT_METER = 5; // 5 metros por quadrado de malha (para snapping e visual)
        
        // VARIÁVEIS DE ESCALA
        let currentZoomScale = 1.0;
        let PIXELS_PER_METER = BASE_PIXELS_PER_METER * currentZoomScale; 

        const BALL_COLLISION_COR = 0.95; 
        const WALL_COR = 0.95; 

        const BASE_RADIUS_M = 0.2; 
        const COLORS = ['#e74c3c', '#3498db', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22'];
        let colorIndex = 0;

        // -----------------------------------
        // 2. VARIÁVEIS DE ESTADO DA SIMULAÇÃO
        // -----------------------------------
        let isSimulating = false;
        let animationFrameId = null;
        let lastTime = 0;
        let balls = [];
        let ballIdCounter = 0;
        let currentG = 9.81;
        
        let selectedBall = null;
        let draggingBall = null;
        let dragOffset = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let lastDragTime = 0;


        // -----------------------------------
        // 3. CLASSE BALL
        // -----------------------------------

        class Ball {
            constructor(id, mass, start_x_px, start_y_px) {
                this.id = id;
                this.mass = mass;
                this.radius_m = BASE_RADIUS_M * Math.pow(this.mass, 1/3); 
                
                this.color = COLORS[colorIndex++ % COLORS.length];

                this.x_px = start_x_px;
                this.y_px = start_y_px; 
                this.initial_y_px = start_y_px; // Posição Y no momento da última soltura/quique
                
                this.vx_m = 0; 
                this.vy_m = 0; 
                this.time_in_air = 0;
                this.isDragging = false;
                
                this.element = document.createElement('div');
                this.element.classList.add('ball');
                this.element.id = `ball-${this.id}`;
                this.element.style.backgroundColor = this.color;
                simulationArea.appendChild(this.element);

                this.updateScale(); // Inicializa o radius_px e o tamanho do DOM
                this.render();
                
                // Adiciona listeners para seleção e arrasto
                this.element.addEventListener('mousedown', (e) => {
                    setSelectedBall(this); 
                    handleDragStart(e, this);
                });
                this.element.addEventListener('touchstart', (e) => {
                    e.preventDefault(); 
                    setSelectedBall(this); 
                    handleDragStart(e, this);
                }, { passive: false });
            }
            
            updateScale() {
                this.radius_px = this.radius_m * PIXELS_PER_METER;
                this.element.style.width = `${this.radius_px * 2}px`;
                this.element.style.height = `${this.radius_px * 2}px`;
            }

            updatePosition(dt) {
                if (this.isDragging) return;

                let old_vy_m = this.vy_m; 

                this.vy_m += currentG * dt;
                
                const avg_vy_m = (old_vy_m + this.vy_m) / 2;
                
                let dx_m = this.vx_m * dt;
                let dy_m = avg_vy_m * dt; 
                
                this.x_px += dx_m * PIXELS_PER_METER;
                this.y_px += dy_m * PIXELS_PER_METER;

                if (currentG > 0) {
                    this.time_in_air += dt;
                }
            }

            checkWallCollision() {
                const cor = parseFloat(corInput.value) || 0.85; 
                // Recalcula o chão com a escala atual
                const floor_y_px = SIM_HEIGHT_PX - this.radius_px - FLOOR_HEIGHT_PX; 
                
                // Colisão com o chão
                if (this.y_px > floor_y_px) {
                    this.y_px = floor_y_px;
                    
                    if (Math.abs(this.vy_m) > 0.1) {
                        this.vy_m *= -cor; 
                        this.time_in_air = 0; 
                        // Altura inicial para cálculo cinemático é a altura do chão (zero)
                        this.initial_y_px = floor_y_px; 
                    } else {
                        this.vy_m = 0; 
                        this.vx_m *= 0.95; 
                    }
                }
                
                // Colisão com o teto (apenas para evitar que a bola saia)
                if (this.y_px < this.radius_px) {
                    this.y_px = this.radius_px;
                    this.vy_m *= -WALL_COR; 
                }

                // Colisão com as paredes laterais
                const left_x_px = this.radius_px;
                const right_x_px = SIM_WIDTH_PX - this.radius_px;

                if (this.x_px < left_x_px) {
                    this.x_px = left_x_px;
                    this.vx_m *= -WALL_COR; 
                } else if (this.x_px > right_x_px) {
                    this.x_px = right_x_px;
                    this.vx_m *= -WALL_COR;
                }
            }

            render() {
                this.element.style.left = `${this.x_px - this.radius_px}px`;
                this.element.style.top = `${this.y_px - this.radius_px}px`;
            }
            
            setSelected(isSelected) {
                if (isSelected) {
                    this.element.classList.add('selected');
                } else {
                    this.element.classList.remove('selected');
                }
            }
        }

        // -----------------------------------
        // 4. LÓGICA DE COLISÃO BOLA-BOLA (inalterada)
        // -----------------------------------
        
        function resolveCollision(ballA, ballB) {
            const dx_px = ballB.x_px - ballA.x_px;
            const dy_px = ballB.y_px - ballA.y_px;
            const distance_px = Math.sqrt(dx_px * dx_px + dy_px * dy_px);
            const min_distance_px = ballA.radius_px + ballB.radius_px;

            if (distance_px < min_distance_px) {
                
                // 1. AJUSTE DE POSIÇÃO 
                const overlap_px = min_distance_px - distance_px;
                const angle = Math.atan2(dy_px, dx_px);
                const separation_x = Math.cos(angle) * (overlap_px / 2);
                const separation_y = Math.sin(angle) * (overlap_px / 2);

                ballA.x_px -= separation_x;
                ballA.y_px -= separation_y;
                ballB.x_px += separation_x;
                ballB.y_px += separation_y;
                
                // 2. CÁLCULO DE NOVAS VELOCIDADES
                const normalX = dx_px / distance_px;
                const normalY = dy_px / distance_px;
                
                const relative_vx = ballA.vx_m - ballB.vx_m;
                const relative_vy = ballA.vy_m - ballB.vy_m;
                const speed = relative_vx * normalX + relative_vy * normalY;

                if (speed < 0) return; 

                const total_mass = ballA.mass + ballB.mass;
                const impulse = (BALL_COLLISION_COR + 1) * speed / total_mass;

                ballA.vx_m -= impulse * ballB.mass * normalX;
                ballA.vy_m -= impulse * ballB.mass * normalY;
                ballB.vx_m += impulse * ballA.mass * normalX;
                ballB.vy_m += impulse * ballA.mass * normalY;
            }
        }


        // -----------------------------------
        // 5. LOOP PRINCIPAL E CINEMÁTICA
        // -----------------------------------

        function simulateLoop(timestamp) {
            if (!isSimulating) return;

            // Garante que o tamanho da simulação esteja atualizado
            SIM_WIDTH_PX = simulationArea.offsetWidth;
            SIM_HEIGHT_PX = simulationArea.offsetHeight;

            const dt = (timestamp - lastTime) / 1000; 
            lastTime = timestamp;
            
            balls.forEach(ball => {
                ball.updatePosition(dt);
                ball.checkWallCollision();
            });

            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    resolveCollision(balls[i], balls[j]);
                }
            }

            balls.forEach(ball => ball.render());
            
            updateKinematicsDisplay();

            animationFrameId = requestAnimationFrame(simulateLoop);
        }
        
        function updateKinematicsDisplay() {
            if (!selectedBall) {
                const N_A = 'N/A';
                kinematicsOutput.id.textContent = '-';
                kinematicsOutput.initialHeight.textContent = N_A;
                kinematicsOutput.currentHeight.textContent = N_A;
                kinematicsOutput.timeOfFall.textContent = '0.00 s';
                kinematicsOutput.currentVelocity.textContent = '0.00 m/s';
                kinematicsOutput.theoreticalVelocity.textContent = '0.00 m/s';
                return;
            }
            
            const ball = selectedBall;
            const g = currentG;
            
            const floor_y_px = SIM_HEIGHT_PX - ball.radius_px - FLOOR_HEIGHT_PX;
            
            // Altura em relação ao chão (em metros)
            const initial_height_m = (floor_y_px - ball.initial_y_px) / PIXELS_PER_METER;
            const current_height_m = (floor_y_px - ball.y_px) / PIXELS_PER_METER;
            
            // Deslocamento vertical desde o ponto de partida (em metros)
            const delta_h_m = Math.abs((ball.y_px - ball.initial_y_px) / PIXELS_PER_METER); // Usar valor absoluto
            
            // Velocidade Atual (Magnitude - m/s)
            const velocity_magnitude = Math.sqrt(ball.vx_m * ball.vx_m + ball.vy_m * ball.vy_m);

            let theoretical_v = 0;
            
            if (g > 0) {
                // Cálculo mais preciso, considerando apenas a queda
                // v = sqrt(v0y^2 + 2g*dh)
                // Se a bola foi solta/quicou, consideramos v0y como 0 para o cálculo teórico
                if (ball.time_in_air > 0) {
                     // Velocidade de queda teórica: v = g * t
                     theoretical_v = g * ball.time_in_air;
                } else if (delta_h_m > 0) {
                     // Alternativa (baseado na altura): v = sqrt(2*g*dh)
                     theoretical_v = Math.sqrt(2 * g * delta_h_m); 
                }
            } else {
                theoretical_v = velocity_magnitude;
            }

            // Atualiza a exibição
            kinematicsOutput.id.textContent = ball.id;
            kinematicsOutput.initialHeight.textContent = `${Math.max(0, initial_height_m).toFixed(2)} m`;
            kinematicsOutput.currentHeight.textContent = `${Math.max(0, current_height_m).toFixed(2)} m`;
            kinematicsOutput.timeOfFall.textContent = `${ball.time_in_air.toFixed(2)} s`;
            kinematicsOutput.currentVelocity.textContent = `${velocity_magnitude.toFixed(2)} m/s`;
            kinematicsOutput.theoreticalVelocity.textContent = `${theoretical_v.toFixed(2)} m/s`;
        }

        // -----------------------------------
        // 6. LÓGICA DE DRAG & DROP E SELEÇÃO
        // -----------------------------------
        // ... (permanece a mesma, usando as novas variáveis de escala) ...
        
        function getMousePos(e) {
            const rect = simulationArea.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function setSelectedBall(ball) {
            if (selectedBall && selectedBall !== ball) {
                selectedBall.setSelected(false);
            }
            selectedBall = ball;
            selectedBall.setSelected(true);
        }

        function handleDragStart(e, ball) {
            e.preventDefault(); 
            
            draggingBall = ball;
            
            if (draggingBall) {
                draggingBall.isDragging = true;
                draggingBall.element.classList.add('dragging');
                
                const mousePos = getMousePos(e);
                
                dragOffset.x = mousePos.x - draggingBall.x_px;
                dragOffset.y = mousePos.y - draggingBall.y_px;
                
                draggingBall.vx_m = 0;
                draggingBall.vy_m = 0;
                
                lastMousePos = mousePos;
                lastDragTime = performance.now();
                
                // Ao iniciar o arraste, a posição atual se torna a nova 'inicial'
                draggingBall.initial_y_px = draggingBall.y_px; 
                draggingBall.time_in_air = 0;
            }
        }

        function handleMouseMove(e) {
            if (!draggingBall) return;
            e.preventDefault(); 
            
            const mousePos = getMousePos(e);
            const now = performance.now();
            const dt_ms = now - lastDragTime;

            const newX = mousePos.x - dragOffset.x;
            const newY = mousePos.y - dragOffset.y;
            
            const dx_px = newX - draggingBall.x_px;
            const dy_px = newY - draggingBall.y_px;
            
            if (dt_ms > 0) {
                draggingBall.temp_vx_m = (dx_px / PIXELS_PER_METER) / (dt_ms / 1000);
                draggingBall.temp_vy_m = (dy_px / PIXELS_PER_METER) / (dt_ms / 1000);
            }
            
            // Limites de Posição
            const minX = draggingBall.radius_px;
            const maxX = SIM_WIDTH_PX - draggingBall.radius_px;
            const minY = draggingBall.radius_px;
            const maxY = SIM_HEIGHT_PX - draggingBall.radius_px - FLOOR_HEIGHT_PX;

            draggingBall.x_px = Math.min(Math.max(newX, minX), maxX);
            draggingBall.y_px = Math.min(Math.max(newY, minY), maxY);

            draggingBall.render(); 
            
            lastMousePos = mousePos;
            lastDragTime = now;
        }

        function handleMouseUp() {
            if (draggingBall) {
                // Transfere a velocidade calculada
                if (draggingBall.temp_vx_m) {
                    draggingBall.vx_m = draggingBall.temp_vx_m;
                    draggingBall.vy_m = draggingBall.temp_vy_m;
                }
                
                // Atualiza a altura inicial para o ponto de soltura
                draggingBall.initial_y_px = draggingBall.y_px;
                draggingBall.time_in_air = 0;
                
                draggingBall.isDragging = false;
                draggingBall.element.classList.remove('dragging');
                draggingBall = null;
            }
        }


        // -----------------------------------
        // 7. FUNÇÕES DE CONTROLE E INICIALIZAÇÃO
        // -----------------------------------
        
        // NOVO: Função para atualizar a escala e o grid
        function updateSimulationScale(newScale) {
            currentZoomScale = newScale;
            PIXELS_PER_METER = BASE_PIXELS_PER_METER * currentZoomScale;
            
            const grid_size_px = GRID_UNIT_METER * PIXELS_PER_METER;
            
            // 1. Atualiza a variável CSS do grid
            simulationArea.style.setProperty('--grid-size', `${grid_size_px}px`);
            
            // 2. Atualiza a exibição do zoom
            currentZoomScaleOutput.textContent = `${currentZoomScale.toFixed(1)}x`;
            gridUnitMeterOutput.textContent = `${GRID_UNIT_METER} metros (${grid_size_px.toFixed(0)}px)`;

            // 3. Recalcula o tamanho de todas as bolas
            balls.forEach(ball => {
                ball.updateScale(); 
                ball.render();
            });
            
            // 4. Garante que os valores de altura inicial no input sejam múltiplos de 5
            const currentHeightVal = parseFloat(initialHeightInput.value) || 5.0;
            initialHeightInput.value = Math.round(currentHeightVal / GRID_UNIT_METER) * GRID_UNIT_METER;
        }

        function initControls() {
            for (const name in GRAVITIES) {
                const option = document.createElement('option');
                option.value = GRAVITIES[name];
                option.textContent = name;
                gravitySelect.appendChild(option);
            }

            currentG = parseFloat(gravitySelect.value);
            generalOutput.g.textContent = `${currentG.toFixed(2)} m/s²`;
            generalOutput.cor.textContent = corInput.value;
            
            // Inicializa a escala e o grid
            updateSimulationScale(parseFloat(zoomScaleInput.value));
            
            // Listeners de Escala
            zoomScaleInput.addEventListener('input', (e) => {
                updateSimulationScale(parseFloat(e.target.value));
            });
            
            // Listeners de Altura Inicial (garante múltiplo de 5)
            initialHeightInput.addEventListener('input', () => {
                let val = parseFloat(initialHeightInput.value);
                if (val < GRID_UNIT_METER) {
                    initialHeightInput.value = GRID_UNIT_METER;
                } else {
                    // Snapping visual/funcional ao múltiplo de 5 mais próximo
                    initialHeightInput.value = Math.round(val / GRID_UNIT_METER) * GRID_UNIT_METER;
                }
            });
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchmove', handleMouseMove, { passive: false });
            document.addEventListener('touchend', handleMouseUp);
        }

        function toggleSimulation() {
            if (balls.length === 0) {
                 alert('Adicione pelo menos uma bola antes de iniciar!');
                 return;
            }

            isSimulating = !isSimulating;
            
            if (isSimulating) {
                startButton.textContent = 'PAUSAR SIMULAÇÃO';
                startButton.style.backgroundColor = '#f39c12';
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(simulateLoop);
            } else {
                startButton.textContent = 'RETOMAR SIMULAÇÃO';
                startButton.style.backgroundColor = '#D2691E';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            }
        }
        
        function addBall() {
            const mass = parseFloat(massInput.value) || 1.0;
            const initial_height_m_raw = parseFloat(initialHeightInput.value) || 5.0; 
            
            SIM_WIDTH_PX = simulationArea.offsetWidth;
            SIM_HEIGHT_PX = simulationArea.offsetHeight;
            
            // 1. Snapping da altura inicial (múltiplo de 5m mais próximo)
            const snapped_height_m = Math.round(initial_height_m_raw / GRID_UNIT_METER) * GRID_UNIT_METER;
            
            // Raio da bola na escala atual (em pixels)
            const ball_radius_m = BASE_RADIUS_M * Math.pow(mass, 1/3);
            const ball_radius_px = ball_radius_m * PIXELS_PER_METER;

            // 2. Posição Y (Centro da bola) em pixels a partir do topo
            // Pos Y = Altura Total - Altura Desejada - Raio - Altura do Chão
            let start_y_px = SIM_HEIGHT_PX - (snapped_height_m * PIXELS_PER_METER) - ball_radius_m * PIXELS_PER_METER - FLOOR_HEIGHT_PX;
            
            // Garante que a bola não inicie acima do limite superior
            start_y_px = Math.max(start_y_px, ball_radius_px);


            // 3. Posição X (Centro da bola)
            // Posição x aleatória, mas snappada ao grid também
            let initial_x_m = ((SIM_WIDTH_PX / 2) + ((ballIdCounter % 2 === 0 ? 1 : -1) * (15 + (ballIdCounter * 5)))) / PIXELS_PER_METER;
            const snapped_x_m = Math.round(initial_x_m / GRID_UNIT_METER) * GRID_UNIT_METER;
            let start_x_px = snapped_x_m * PIXELS_PER_METER;

            // Garante que x_px fique dentro dos limites
            const min_x_px = ball_radius_px;
            const max_x_px = SIM_WIDTH_PX - min_x_px;
            start_x_px = Math.min(Math.max(start_x_px, min_x_px), max_x_px);


            const newBall = new Ball(ballIdCounter++, mass, start_x_px, start_y_px);
            balls.push(newBall);
            
            generalOutput.ballCount.textContent = balls.length;
            
            setSelectedBall(newBall);
            
            if (balls.length === 1 && !isSimulating) {
                toggleSimulation();
            }
        }

        function resetAll() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            isSimulating = false;
            startButton.textContent = 'INICIAR SIMULAÇÃO';
            startButton.style.backgroundColor = '#D2691E';

            balls.forEach(ball => ball.element.remove());
            balls = [];
            ballIdCounter = 0;
            colorIndex = 0;
            selectedBall = null;
            generalOutput.ballCount.textContent = 0;
            updateKinematicsDisplay(); // Limpa o painel
        }
        
        // Listeners
        startButton.addEventListener('click', toggleSimulation);
        addBallButton.addEventListener('click', addBall);
        resetAllButton.addEventListener('click', resetAll);

        gravitySelect.addEventListener('change', () => {
            currentG = parseFloat(gravitySelect.value);
            generalOutput.g.textContent = `${currentG.toFixed(2)} m/s²`;
        });

        corInput.addEventListener('input', () => {
             generalOutput.cor.textContent = corInput.value;
             let cor = parseFloat(corInput.value);
             if (cor > 1.0) corInput.value = 1.0;
             if (cor < 0.0) corInput.value = 0.0;
        });

        // Inicialização
        initControls();
        
        // Listener para garantir que as dimensões do simulador estejam corretas
        window.addEventListener('resize', () => {
             // Recalcula as dimensões em pixels da área de simulação
             SIM_WIDTH_PX = simulationArea.offsetWidth;
             SIM_HEIGHT_PX = simulationArea.offsetHeight;
             // Como a escala mudou, re-renderiza para garantir que as bolas fiquem no lugar (apenas em caso de resize)
             balls.forEach(ball => ball.render());
        });
        
    </script>
</body>
</html>
