<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Geometria Analítica (V6 - Elipse)</title>
    <style>
        /* --- LAYOUT DE TELA CHEIA --- */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background-color: #f4f4f4;
        }

        #planoCartesiano {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            background-color: #fff;
            cursor: crosshair;
        }

        /* --- PAINEL DE CONTROLE E RESULTADOS --- */
        .controls-panel {
            position: fixed;
            top: 20px; right: 20px;
            width: 340px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            z-index: 10;
            overflow-y: auto;
            max-height: calc(100vh - 40px);
        }

        h2 {
            text-align: left; color: #333; margin-top: 0; margin-bottom: 15px;
            border-bottom: 2px solid #e74c3c; padding-bottom: 10px;
        }
        h4 {
            color: #555; margin-top: 10px; margin-bottom: 10px;
        }

        /* --- SELETOR DE MODO (GRID) --- */
        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Default 2 colunas */
            gap: 5px;
            background-color: #eee;
            border-radius: 4px;
            padding: 5px;
            margin-bottom: 15px;
        }
        .mode-selector label {
            padding: 8px; text-align: center; font-weight: bold;
            cursor: pointer; transition: background-color 0.3s, color 0.3s;
            border-radius: 4px; font-size: 0.9em;
        }
        .mode-selector input { display: none; }
        .mode-selector input:checked + label {
            background-color: #3498db;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* Ajuste para 5 modos */
        .mode-selector.five-modes {
             grid-template-columns: 1fr 1fr 1fr; /* 3 colunas para caber Elipse */
        }
        .mode-selector .full-width { grid-column: 1 / -1; }
        .mode-selector .span-two { grid-column: span 2; }


        .info-group {
            padding: 10px; background-color: #f9f9f9;
            border: 1px solid #eee; border-radius: 4px;
            margin-bottom: 15px; font-size: 0.9em;
        }
        .info-group.hidden { display: none; }
        .info-group p { margin: 5px 0; font-weight: bold; }
        .info-group span {
            font-family: "Courier New", Courier, monospace;
            font-size: 1.1em; color: #c0392b;
            min-width: 100px; display: inline-block;
        }

        /* Grupo de Inputs para Elipse */
        .input-param-group {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f0faff;
            border: 1px solid #cceeff;
            border-radius: 4px;
        }
        .input-param-group.hidden { display: none; }
        .input-param-group label {
            display: inline-block;
            width: 30px;
            font-weight: bold;
            margin-right: 5px;
        }
        .input-param-group input {
            width: 80px;
            padding: 5px 8px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
        }

        .results {
            border-top: 1px solid #eee; padding-top: 15px;
        }
        .results.hidden { display: none; }
        .results p {
            margin: 10px 0; font-size: 1em; display: flex;
            justify-content: space-between; align-items: center;
        }
        .results strong { color: #000; font-family: Arial, sans-serif; flex-shrink: 0; margin-right: 10px; }
        .results span {
            font-family: "Courier New", Courier, monospace;
            font-weight: bold; color: #3498db;
            text-align: right; word-break: break-all;
        }

        /* Estilo para o resultado da Posição */
        .posicao-resultado {
            font-size: 1.2em; font-weight: bold; text-align: center;
            padding: 10px; border-radius: 4px; margin-top: 10px;
        }
        .posicao-resultado.secante { background-color: #e8f8f5; color: #1abc9c; }
        .posicao-resultado.tangente { background-color: #fef9e7; color: #f1c40f; }
        .posicao-resultado.externa { background-color: #fdedec; color: #e74c3c; }
        .posicao-resultado.paralelas { background-color: #f4ecf7; color: #8e44ad; }
        .posicao-resultado.perpendiculares { background-color: #fef5e7; color: #e67e22; }
        .posicao-resultado.concorrentes { background-color: #eaf2f8; color: #3498db; }


        button {
            width: 100%; padding: 12px; background-color: #e74c3c;
            color: white; border: none; border-radius: 4px;
            font-size: 1em; font-weight: bold; cursor: pointer;
            transition: background-color 0.3s; margin-top: 10px;
        }
        button:hover { background-color: #c0392b; }
    </style>
</head>
<body>

    <canvas id="planoCartesiano"></canvas>

    <div class="controls-panel">
        <h2>Geometria Analítica</h2>

        <div class="mode-selector five-modes">
            <input type="radio" id="modeReta" name="mode" value="reta" checked>
            <label for="modeReta">Reta</label>
            <input type="radio" id="modeCirc" name="mode" value="circunferencia">
            <label for="modeCirc">Círculo</label>
            <input type="radio" id="modeElipse" name="mode" value="elipse">
            <label for="modeElipse">Elipse</label>
            <input type="radio" id="modeDuasRetas" name="mode" value="duasRetas">
            <label for="modeDuasRetas">Duas Retas</label>
            <input type="radio" id="modePosicao" name="mode" value="posicao">
            <label for="modePosicao" class="span-two">Reta + Círculo</label>
        </div>

        <p id="instructionText" style="font-size: 0.9em; margin-bottom: 15px; color: #555;">
            Clique no plano para definir o Ponto A.
        </p>

        <div class="info-group" id="infoPontos">
            </div>

        <div class="input-param-group hidden" id="inputElipse">
             <h4>Parâmetros da Elipse (a > b > 0):</h4>
             <div>
                 <label for="elipse_a">a:</label>
                 <input type="number" id="elipse_a" value="5" min="0.1" step="0.1">
                 <label for="elipse_b">b:</label>
                 <input type="number" id="elipse_b" value="3" min="0.1" step="0.1">
             </div>
        </div>

        <div class="results" id="resultsReta">
            <h4>Resultados da Reta:</h4>
            <p><strong>Distância (A, B):</strong> <span id="distancia"> - </span></p>
            <p><strong>Ponto Médio (M):</strong> <span id="pontoMedio"> - </span></p>
            <p><strong>Coef. Angular (m):</strong> <span id="coefAngular"> - </span></p>
            <p><strong>Ângulo de Incl. (θ):</strong> <span id="anguloInclinacao"> - </span></p>
            <p><strong>Coef. Linear (n):</strong> <span id="coefLinear"> - </span></p>
            <p><strong>Equação da Reta:</strong> <span id="eqReta"> - </span></p>
        </div>

        <div class="results hidden" id="resultsCirc">
            <h4>Resultados da Circunferência:</h4>
            <p><strong>Centro (C):</strong> <span id="centroCoords"> - </span></p>
            <p><strong>Raio (R):</strong> <span id="raioValor"> - </span></p>
            <p><strong>Equação Reduzida:</strong> <span id="eqCirc"> - </span></p>
            <p><strong>Equação Geral:</strong> <span id="eqGeralCirc"> - </span></p>
        </div>

        <div class="results hidden" id="resultsElipse">
            <h4>Resultados da Elipse:</h4>
            <p><strong>Semi-eixo a:</strong> <span id="elipse_a_out"> - </span></p>
            <p><strong>Semi-eixo b:</strong> <span id="elipse_b_out"> - </span></p>
            <p><strong>Dist. Focal (c):</strong> <span id="elipse_c"> - </span></p>
            <p><strong>Excentricidade (e):</strong> <span id="elipse_e"> - </span></p>
            <p><strong>Equação Reduzida:</strong> <span id="eqElipse"> - </span></p>
        </div>

        <div class="results hidden" id="resultsPosicao">
            <h4>Resultados da Posição Relativa:</h4>
            <p><strong>Raio (R):</strong> <span id="posRaio"> - </span></p>
            <p><strong>Distância (d):</strong> <span id="posDistancia"> - </span></p>
            <div id="posicaoResultado" class="posicao-resultado"> - </div>
        </div>

        <div class="results hidden" id="resultsDuasRetas">
            <h4>Resultados (Duas Retas):</h4>
            <p><strong>Coef. Angular (mᵣ):</strong> <span id="duasRetas_mr"> - </span></p>
            <p><strong>Coef. Angular (mₛ):</strong> <span id="duasRetas_ms"> - </span></p>
            <div id="posicaoDuasRetasResultado" class="posicao-resultado"> - </div>
        </div>

        <button id="limparPontos">Limpar Pontos / Reset</button>
    </div>

    <script>
        // --- Elementos DOM ---
        const canvas = document.getElementById('planoCartesiano');
        const ctx = canvas.getContext('2d');
        const btnLimpar = document.getElementById('limparPontos');
        const instructionText = document.getElementById('instructionText');

        const infoPontosDiv = document.getElementById('infoPontos');
        const inputElipseDiv = document.getElementById('inputElipse');
        const resultsRetaDiv = document.getElementById('resultsReta');
        const resultsCircDiv = document.getElementById('resultsCirc');
        const resultsElipseDiv = document.getElementById('resultsElipse');
        const resultsPosicaoDiv = document.getElementById('resultsPosicao');
        const resultsDuasRetasDiv = document.getElementById('resultsDuasRetas');
        const radioModes = document.querySelectorAll('input[name="mode"]');

        // Spans de Saída (Reta)
        const spanDistancia = document.getElementById('distancia');
        const spanPontoMedio = document.getElementById('pontoMedio');
        const spanCoefAngular = document.getElementById('coefAngular');
        const spanAnguloInclinacao = document.getElementById('anguloInclinacao');
        const spanCoefLinear = document.getElementById('coefLinear');
        const spanEqReta = document.getElementById('eqReta');

        // Spans de Saída (Circunferência)
        const spanCentroCoords = document.getElementById('centroCoords');
        const spanRaioValor = document.getElementById('raioValor');
        const spanEqCirc = document.getElementById('eqCirc');
        const spanEqGeralCirc = document.getElementById('eqGeralCirc');

        // Spans de Saída (Elipse)
        const elipseInputA = document.getElementById('elipse_a');
        const elipseInputB = document.getElementById('elipse_b');
        const spanElipseA = document.getElementById('elipse_a_out');
        const spanElipseB = document.getElementById('elipse_b_out');
        const spanElipseC = document.getElementById('elipse_c');
        const spanElipseE = document.getElementById('elipse_e');
        const spanEqElipse = document.getElementById('eqElipse');

        // Spans de Saída (Posição)
        const spanPosRaio = document.getElementById('posRaio');
        const spanPosDistancia = document.getElementById('posDistancia');
        const divPosicaoResultado = document.getElementById('posicaoResultado');

        // Spans de Saída (Duas Retas)
        const spanDuasRetas_mr = document.getElementById('duasRetas_mr');
        const spanDuasRetas_ms = document.getElementById('duasRetas_ms');
        const divPosicaoDuasRetasResultado = document.getElementById('posicaoDuasRetasResultado');

        // --- Configurações do Plano Cartesiano ---
        let origemX, origemY;
        const escala = 20;

        const COR_GRADE = '#f0f0f0', COR_EIXOS = '#999';
        const COR_PONTO_A = '#e74c3c', COR_PONTO_B = '#3498db', COR_PONTO_C = '#2ecc71', COR_PONTO_D = '#f1c40f';
        const COR_RETA_R = 'rgba(52, 152, 219, 0.7)', COR_RETA_S = 'rgba(231, 76, 60, 0.7)';
        const COR_CIRC = 'rgba(46, 204, 113, 0.7)';
        const COR_ELIPSE = 'rgba(155, 89, 182, 0.7)';

        // --- Estado da Aplicação ---
        let currentMode = 'reta';
        let pontoA = null, pontoB = null, pontoC = null, pontoD = null;
        let pontoCentro = null, pontoRaio = null;

        // --- Funções de Coordenadas e Helpers ---
        function pixelParaCartesiano(px, py) { /* ... */ return { x: (px - origemX) / escala, y: (origemY - py) / escala }; }
        function cartesianoParaPixel(x, y) { /* ... */ return { x: (x * escala) + origemX, y: origemY - (y * escala) }; }
        function getDistancia(p1, p2) { /* ... */ return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)); }
        function formatTerm(num, showPlus = false) { /* ... */ if (Math.abs(num) < 0.001) return ""; const sign = num >= 0 ? (showPlus ? '+' : '') : '-'; return ` ${sign} ${Math.abs(num).toFixed(2)}`; }
        function getCoefAngular(p1, p2) { /* ... */ if(!p1 || !p2) return NaN; const dx = p2.x - p1.x; const dy = p2.y - p1.y; if (Math.abs(dx) < 0.001) return Infinity; if (Math.abs(dy) < 0.001) return 0; return dy / dx; }

        // --- Funções de Desenho ---
        function desenharPlano() { /* ... (Idêntico) */
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = COR_GRADE; ctx.lineWidth = 1;
            for (let x = origemX; x < canvas.width; x += escala) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let x = origemX; x > 0; x -= escala) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = origemY; y < canvas.height; y += escala) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = origemY; y > 0; y -= escala) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            ctx.strokeStyle = COR_EIXOS; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, origemY); ctx.lineTo(canvas.width, origemY); ctx.stroke(); // X
            ctx.beginPath(); ctx.moveTo(origemX, 0); ctx.lineTo(origemX, canvas.height); ctx.stroke(); // Y
        }
        function desenharLinha(p1, p2, cor, nomeP1, nomeP2) { /* ... (Idêntico) */
            if (p1) { const p = cartesianoParaPixel(p1.x, p1.y); ctx.fillStyle = cor; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI); ctx.fill(); ctx.font = 'bold 16px Arial'; ctx.fillStyle = '#000'; ctx.fillText(nomeP1, p.x + 15, p.y); }
            if (p2) { const p = cartesianoParaPixel(p2.x, p2.y); ctx.fillStyle = cor; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI); ctx.fill(); ctx.font = 'bold 16px Arial'; ctx.fillStyle = '#000'; ctx.fillText(nomeP2, p.x + 15, p.y); }
            if (p1 && p2) {
                ctx.strokeStyle = cor; ctx.lineWidth = 3;
                const dx = p2.x - p1.x; const dy = p2.y - p1.y;
                if (Math.abs(dx) < 0.001) {
                    const pStart = cartesianoParaPixel(p1.x, -1000); const pEnd = cartesianoParaPixel(p1.x, 1000);
                    ctx.beginPath(); ctx.moveTo(pStart.x, pStart.y); ctx.lineTo(pEnd.x, pEnd.y); ctx.stroke();
                } else {
                    const m = dy / dx; const b = p1.y - m * p1.x;
                    const x_min_cart = pixelParaCartesiano(0, 0).x - 100; const x_max_cart = pixelParaCartesiano(canvas.width, 0).x + 100;
                    const y_start = m * x_min_cart + b; const y_end = m * x_max_cart + b;
                    const pStart = cartesianoParaPixel(x_min_cart, y_start); const pEnd = cartesianoParaPixel(x_max_cart, y_end);
                    ctx.beginPath(); ctx.moveTo(pStart.x, pStart.y); ctx.lineTo(pEnd.x, pEnd.y); ctx.stroke();
                }
            }
        }
        function desenharCircunferencia() { /* ... (Idêntico) */
            if (pontoCentro) { const pC = cartesianoParaPixel(pontoCentro.x, pontoCentro.y); ctx.fillStyle = COR_PONTO_C; ctx.beginPath(); ctx.arc(pC.x, pC.y, 6, 0, 2 * Math.PI); ctx.fill(); ctx.font = 'bold 16px Arial'; ctx.fillStyle = '#000'; ctx.fillText('C', pC.x + 15, pC.y); }
            if (pontoRaio) { const pR = cartesianoParaPixel(pontoRaio.x, pontoRaio.y); ctx.fillStyle = COR_PONTO_A; ctx.beginPath(); ctx.arc(pR.x, pR.y, 6, 0, 2 * Math.PI); ctx.fill(); ctx.font = 'bold 16px Arial'; ctx.fillStyle = '#000'; ctx.fillText('P', pR.x + 15, pR.y); }
            if (pontoCentro && pontoRaio) {
                const pC = cartesianoParaPixel(pontoCentro.x, pontoCentro.y); const pR = cartesianoParaPixel(pontoRaio.x, pontoRaio.y);
                const raioPx = Math.sqrt(Math.pow(pR.x - pC.x, 2) + Math.pow(pR.y - pC.y, 2));
                ctx.strokeStyle = COR_CIRC; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(pC.x, pC.y); ctx.lineTo(pR.x, pR.y); ctx.stroke(); ctx.setLineDash([]);
                ctx.strokeStyle = COR_CIRC; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(pC.x, pC.y, raioPx, 0, 2 * Math.PI); ctx.stroke();
            }
        }
        function desenharElipse() { /* ... (Idêntico) */
            const a = parseFloat(elipseInputA.value) || 0;
            const b = parseFloat(elipseInputB.value) || 0;
            if (a <= 0 || b <= 0 || b >= a) return;
            const raioX = a * escala; const raioY = b * escala;
            ctx.strokeStyle = COR_ELIPSE; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.ellipse(origemX, origemY, raioX, raioY, 0, 0, 2 * Math.PI); ctx.stroke();
            if (a > b) {
                const c = Math.sqrt(a*a - b*b);
                const foco1 = cartesianoParaPixel(c, 0); const foco2 = cartesianoParaPixel(-c, 0);
                ctx.fillStyle = '#8e44ad';
                ctx.beginPath(); ctx.arc(foco1.x, foco1.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(foco2.x, foco2.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.font = 'bold 14px Arial'; ctx.fillText('F1', foco1.x + 10, foco1.y); ctx.fillText('F2', foco2.x - 20, foco2.y);
            }
            else if (b > a) {
                 const c = Math.sqrt(b*b - a*a);
                const foco1 = cartesianoParaPixel(0, c); const foco2 = cartesianoParaPixel(0, -c);
                ctx.fillStyle = '#8e44ad';
                ctx.beginPath(); ctx.arc(foco1.x, foco1.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.arc(foco2.x, foco2.y, 5, 0, 2 * Math.PI); ctx.fill();
                ctx.font = 'bold 14px Arial'; ctx.fillText('F1', foco1.x + 10, foco1.y); ctx.fillText('F2', foco2.x + 10, foco2.y);
            }
        }
        function desenharTudo() { /* ... (Idêntico) */
            desenharPlano();
            if (currentMode === 'reta') { desenharLinha(pontoA, pontoB, COR_RETA_R, 'A', 'B'); }
            else if (currentMode === 'circunferencia') { desenharCircunferencia(); }
            else if (currentMode === 'posicao') { desenharLinha(pontoA, pontoB, COR_RETA_R, 'A', 'B'); desenharCircunferencia(); }
            else if (currentMode === 'duasRetas') { desenharLinha(pontoA, pontoB, COR_RETA_R, 'A', 'B'); desenharLinha(pontoC, pontoD, COR_RETA_S, 'C', 'D'); }
            else if (currentMode === 'elipse') { desenharElipse(); }
        }

        // --- Funções de Cálculo e UI ---

        function atualizarPainel() {
            // Esconde tudo
            resultsRetaDiv.classList.add('hidden');
            resultsCircDiv.classList.add('hidden');
            resultsPosicaoDiv.classList.add('hidden');
            resultsDuasRetasDiv.classList.add('hidden');
            resultsElipseDiv.classList.add('hidden');
            infoPontosDiv.classList.remove('hidden');
            inputElipseDiv.classList.add('hidden');

            switch (currentMode) {
                case 'reta': {
                    resultsRetaDiv.classList.remove('hidden');
                    infoPontosDiv.innerHTML = `<p>Ponto A: <span>${pontoA ? `(${pontoA.x.toFixed(2)}, ${pontoA.y.toFixed(2)})` : '( - )'}</span></p><p>Ponto B: <span>${pontoB ? `(${pontoB.x.toFixed(2)}, ${pontoB.y.toFixed(2)})` : '( - )'}</span></p>`;
                    if (!pontoA) { instructionText.textContent = "Clique no plano para definir o Ponto A."; } else if (!pontoB) { instructionText.textContent = "Clique no plano para definir o Ponto B."; } else { instructionText.textContent = "Clique para reiniciar e definir um novo Ponto A."; }
                    if (!pontoA || !pontoB) { spanDistancia.textContent = '-'; spanPontoMedio.textContent = '-'; spanCoefAngular.textContent = '-'; spanEqReta.textContent = '-'; spanAnguloInclinacao.textContent = '-'; spanCoefLinear.textContent = '-'; break; }
                    const dist = getDistancia(pontoA, pontoB);
                    const medX = (pontoA.x + pontoB.x) / 2; const medY = (pontoA.y + pontoB.y) / 2;
                    spanDistancia.textContent = dist.toFixed(3); spanPontoMedio.textContent = `(${medX.toFixed(2)}, ${medY.toFixed(2)})`;
                    const m = getCoefAngular(pontoA, pontoB);
                    if (m === Infinity) { spanCoefAngular.textContent = 'Indefinido'; spanAnguloInclinacao.textContent = '90.0°'; spanCoefLinear.textContent = 'N/A'; spanEqReta.textContent = `x = ${pontoA.x.toFixed(2)}`; }
                    else if (m === 0) { spanCoefAngular.textContent = '0.000'; spanAnguloInclinacao.textContent = '0.0°'; const n = pontoA.y; spanCoefLinear.textContent = n.toFixed(3); spanEqReta.textContent = `y = ${n.toFixed(2)}`; }
                    else {
                        let anguloDeg = Math.atan(m) * (180 / Math.PI);
                        if (anguloDeg < 0) { anguloDeg += 180; } // Correção para obter 0-180
                        const n = pontoA.y - m * pontoA.x;
                        spanCoefAngular.textContent = m.toFixed(3); spanAnguloInclinacao.textContent = `${anguloDeg.toFixed(2)}°`;
                        spanCoefLinear.textContent = n.toFixed(3); spanEqReta.textContent = `y = ${m.toFixed(2)}x ${formatTerm(n, true)}`;
                    }
                    break;
                }

                case 'circunferencia': {
                    resultsCircDiv.classList.remove('hidden');
                    infoPontosDiv.innerHTML = `<p>Centro C: <span>${pontoCentro ? `(${pontoCentro.x.toFixed(2)}, ${pontoCentro.y.toFixed(2)})` : '( - )'}</span></p><p>Ponto P: <span>${pontoRaio ? `(${pontoRaio.x.toFixed(2)}, ${pontoRaio.y.toFixed(2)})` : '( - )'}</span></p>`;
                    if (!pontoCentro) { instructionText.textContent = "Clique no plano para definir o Centro (C)."; } else if (!pontoRaio) { instructionText.textContent = "Clique na borda para definir o Raio (P)."; } else { instructionText.textContent = "Clique para reiniciar e definir um novo Centro (C)."; }
                    spanCentroCoords.textContent = pontoCentro ? `(${pontoCentro.x.toFixed(2)}, ${pontoCentro.y.toFixed(2)})` : '-';
                    if (!pontoCentro || !pontoRaio) { spanRaioValor.textContent = '-'; spanEqCirc.textContent = '-'; spanEqGeralCirc.textContent = '-'; break; }
                    const raio = getDistancia(pontoCentro, pontoRaio);
                    const R = raio; const a = pontoCentro.x; const b = pontoCentro.y; const R2 = Math.pow(R, 2);
                    spanRaioValor.textContent = R.toFixed(3);
                    spanEqCirc.textContent = `(x ${formatTerm(-a, true)})² + (y ${formatTerm(-b, true)})² = ${R2.toFixed(2)}`;
                    const C_geral = Math.pow(a, 2) + Math.pow(b, 2) - R2;
                    spanEqGeralCirc.textContent = `x² + y² ${formatTerm(-2*a)}x ${formatTerm(-2*b)}y ${formatTerm(C_geral, true)} = 0`;
                    break;
                }

                case 'elipse': {
                    resultsElipseDiv.classList.remove('hidden');
                    inputElipseDiv.classList.remove('hidden');
                    infoPontosDiv.classList.add('hidden');
                    instructionText.textContent = "Digite os semi-eixos 'a' e 'b' (com a > b > 0) e veja a elipse.";
                    const elipseA = parseFloat(elipseInputA.value) || 0;
                    const elipseB = parseFloat(elipseInputB.value) || 0;
                    if (elipseA <= 0 || elipseB <= 0 || elipseB >= elipseA) {
                         spanElipseA.textContent = '-'; spanElipseB.textContent = '-'; spanElipseC.textContent = '-';
                         spanElipseE.textContent = '-'; spanEqElipse.textContent = 'Valores inválidos (a > b > 0)';
                         desenharTudo(); break;
                    }
                    spanElipseA.textContent = elipseA.toFixed(3); spanElipseB.textContent = elipseB.toFixed(3);
                    const c = Math.sqrt(elipseA*elipseA - elipseB*elipseB); const e = c / elipseA;
                    spanElipseC.textContent = c.toFixed(3); spanElipseE.textContent = e.toFixed(3);
                    spanEqElipse.textContent = `x²/${(elipseA*elipseA).toFixed(2)} + y²/${(elipseB*elipseB).toFixed(2)} = 1`;
                    desenharTudo();
                    break;
                 }

                case 'duasRetas': {
                    resultsDuasRetasDiv.classList.remove('hidden');
                    infoPontosDiv.innerHTML = `<p style="color:${COR_RETA_R}">Reta r (A): <span>${pontoA ? `(${pontoA.x.toFixed(2)}, ${pontoA.y.toFixed(2)})` : '( - )'}</span></p><p style="color:${COR_RETA_R}">Reta r (B): <span>${pontoB ? `(${pontoB.x.toFixed(2)}, ${pontoB.y.toFixed(2)})` : '( - )'}</span></p><hr><p style="color:${COR_RETA_S}">Reta s (C): <span>${pontoC ? `(${pontoC.x.toFixed(2)}, ${pontoC.y.toFixed(2)})` : '( - )'}</span></p><p style="color:${COR_RETA_S}">Reta s (D): <span>${pontoD ? `(${pontoD.x.toFixed(2)}, ${pontoD.y.toFixed(2)})` : '( - )'}</span></p>`;
                    if (!pontoA) { instructionText.textContent = "Passo 1: Clique para definir o Ponto A (Reta r)."; } else if (!pontoB) { instructionText.textContent = "Passo 2: Clique para definir o Ponto B (Reta r)."; } else if (!pontoC) { instructionText.textContent = "Passo 3: Clique para definir o Ponto C (Reta s)."; } else if (!pontoD) { instructionText.textContent = "Passo 4: Clique para definir o Ponto D (Reta s)."; } else { instructionText.textContent = "Clique para reiniciar e definir um novo Ponto A."; }
                    if (!pontoA || !pontoB || !pontoC || !pontoD) { spanDuasRetas_mr.textContent = '-'; spanDuasRetas_ms.textContent = '-'; divPosicaoDuasRetasResultado.textContent = '-'; divPosicaoDuasRetasResultado.className = 'posicao-resultado'; break; }
                    const mr = getCoefAngular(pontoA, pontoB); const ms = getCoefAngular(pontoC, pontoD);
                    spanDuasRetas_mr.textContent = (mr === Infinity) ? 'Indefinido' : mr.toFixed(3); spanDuasRetas_ms.textContent = (ms === Infinity) ? 'Indefinido' : ms.toFixed(3);
                    const epsilon = 0.01;
                    if (mr === ms || Math.abs(mr - ms) < epsilon || (mr === Infinity && ms === Infinity)) { divPosicaoDuasRetasResultado.textContent = "PARALELAS (mᵣ = mₛ)"; divPosicaoDuasRetasResultado.className = "posicao-resultado paralelas"; }
                    else if (Math.abs(mr * ms + 1) < epsilon || (mr === 0 && ms === Infinity) || (ms === 0 && mr === Infinity)) { divPosicaoDuasRetasResultado.textContent = "PERPENDICULARES (mᵣ * mₛ = -1)"; divPosicaoDuasRetasResultado.className = "posicao-resultado perpendiculares"; }
                    else { divPosicaoDuasRetasResultado.textContent = "CONCORRENTES (mᵣ ≠ mₛ)"; divPosicaoDuasRetasResultado.className = "posicao-resultado concorrentes"; }
                    break;
                }

                case 'posicao': {
                    resultsPosicaoDiv.classList.remove('hidden');
                    infoPontosDiv.innerHTML = `<p style="color:${COR_CIRC}">Centro C: <span>${pontoCentro ? `(${pontoCentro.x.toFixed(2)}, ${pontoCentro.y.toFixed(2)})` : '( - )'}</span></p><p style="color:${COR_CIRC}">Ponto P: <span>${pontoRaio ? `(${pontoRaio.x.toFixed(2)}, ${pontoRaio.y.toFixed(2)})` : '( - )'}</span></p><hr><p style="color:${COR_RETA_R}">Reta (A): <span>${pontoA ? `(${pontoA.x.toFixed(2)}, ${pontoA.y.toFixed(2)})` : '( - )'}</span></p><p style="color:${COR_RETA_R}">Reta (B): <span>${pontoB ? `(${pontoB.x.toFixed(2)}, ${pontoB.y.toFixed(2)})` : '( - )'}</span></p>`;
                    if (!pontoCentro) { instructionText.textContent = "Passo 1: Clique para definir o Centro (C)."; } else if (!pontoRaio) { instructionText.textContent = "Passo 2: Clique para definir o Raio (P)."; } else if (!pontoA) { instructionText.textContent = "Passo 3: Clique para definir o Ponto A da reta."; } else if (!pontoB) { instructionText.textContent = "Passo 4: Clique para definir o Ponto B da reta."; } else { instructionText.textContent = "Clique para reiniciar e definir um novo Centro (C)."; }
                    if (!pontoCentro || !pontoRaio || !pontoA || !pontoB) { spanPosRaio.textContent = '-'; spanPosDistancia.textContent = '-'; divPosicaoResultado.textContent = '-'; divPosicaoResultado.className = 'posicao-resultado'; break; }
                    const R = getDistancia(pontoCentro, pontoRaio); spanPosRaio.textContent = R.toFixed(3);
                    const C = pontoCentro; let d = 0;
                    const m_reta = getCoefAngular(pontoA, pontoB);
                    if (m_reta === Infinity) { d = Math.abs(C.x - pontoA.x); }
                    else { const n_reta = pontoA.y - m_reta * pontoA.x; d = Math.abs(m_reta * C.x - 1 * C.y + n_reta) / Math.sqrt(Math.pow(m_reta, 2) + 1); }
                    spanPosDistancia.textContent = d.toFixed(3);
                    const epsilon_pos = 0.01;
                    if (Math.abs(d - R) < epsilon_pos) { divPosicaoResultado.textContent = "TANGENTE (d = R)"; divPosicaoResultado.className = "posicao-resultado tangente"; }
                    else if (d < R) { divPosicaoResultado.textContent = "SECANTE (d < R)"; divPosicaoResultado.className = "posicao-resultado secante"; }
                    else { divPosicaoResultado.textContent = "EXTERNA (d > R)"; divPosicaoResultado.className = "posicao-resultado externa"; }
                    break;
                }
            }
        }

        // --- Funções de Eventos ---
        function handleResize() { /* ... (Idêntico) */
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            origemX = canvas.width / 2; origemY = canvas.height / 2;
            desenharTudo();
        }

        function handleClickCanvas(event) {
            if (event.target !== canvas || currentMode === 'elipse') return; // Ignora clique se for elipse

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const coords = pixelParaCartesiano(mouseX, mouseY);
            const pontoClicado = {
                x: Math.round(coords.x * 2) / 2,
                y: Math.round(coords.y * 2) / 2
            };

            switch (currentMode) {
                case 'reta':
                    if (!pontoA) { pontoA = pontoClicado; } else if (!pontoB) { pontoB = pontoClicado; } else { pontoA = pontoClicado; pontoB = null; } break;
                case 'circunferencia':
                    if (!pontoCentro) { pontoCentro = pontoClicado; } else if (!pontoRaio) { pontoRaio = pontoClicado; } else { pontoCentro = pontoClicado; pontoRaio = null; } break;
                case 'posicao':
                    if (!pontoCentro) { pontoCentro = pontoClicado; } else if (!pontoRaio) { pontoRaio = pontoClicado; } else if (!pontoA) { pontoA = pontoClicado; } else if (!pontoB) { pontoB = pontoClicado; } else { pontoCentro = pontoClicado; pontoRaio = null; pontoA = null; pontoB = null; } break;
                case 'duasRetas':
                    if (!pontoA) { pontoA = pontoClicado; } else if (!pontoB) { pontoB = pontoClicado; } else if (!pontoC) { pontoC = pontoClicado; } else if (!pontoD) { pontoD = pontoClicado; } else { pontoA = pontoClicado; pontoB = null; pontoC = null; pontoD = null; } break;
            }
            atualizarPainel();
            desenharTudo();
        }

        function limparTudo() { /* ... (Idêntico) */
            pontoA = null; pontoB = null; pontoC = null; pontoD = null;
            pontoCentro = null; pontoRaio = null;
            elipseInputA.value = 5; elipseInputB.value = 3;
            atualizarPainel(); desenharTudo();
        }

        function mudarModo() { /* ... (Idêntico) */
            currentMode = document.querySelector('input[name="mode"]:checked').value;
            limparTudo();
        }

        // --- Inicialização ---
        function initialize() {
            window.addEventListener('resize', handleResize);
            canvas.addEventListener('click', handleClickCanvas);
            btnLimpar.addEventListener('click', limparTudo);
            radioModes.forEach(radio => radio.addEventListener('change', mudarModo));

            elipseInputA.addEventListener('input', atualizarTudo);
            elipseInputB.addEventListener('input', atualizarTudo);

            handleResize();
            atualizarPainel();
        }

        initialize();
    </script>

</body>
</html>
