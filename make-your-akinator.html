<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIMULAB: Akinator de Blocos (Propriedades Centrais)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        /* ----------------------------------- */
        /* ESTILOS GERAIS E ESTRUTURA */
        /* ----------------------------------- */
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f8f8f8; color: #333; }
        .top-bar { background-color: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); padding: 0 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; z-index: 1000; height: 60px; }
        .logo-link { text-decoration: none; color: #1E90FF; font-size: 18px; font-weight: bold; padding: 15px 0; }
        .simulador-container { display: flex; min-height: calc(100vh - 60px); }
        
        .painel-variaveis { /* Painel à esquerda (Personagens e Propriedades) */
            width: 250px; 
            background-color: #3a3f44;
            color: white;
            padding: 10px;
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            border-right: 1px solid #555;
        }
        
        .painel-comandos { /* Painel central (Paleta de Blocos) */
            width: 280px; 
            background-color: #4a5056; 
            color: white;
            padding: 20px 10px;
            box-shadow: 4px 0 10px rgba(0, 0, 0, 0.1);
            border-right: 1px solid #555;
            overflow-y: auto;
        }
        
        .area-sequencia { /* Workspace de Blocos */
            flex-grow: 1; 
            padding: 20px;
            background-color: #e8e8e8;
            background-image: radial-gradient(circle, #ccc 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto; 
        }
        
        .workspace {
            min-height: 500px;
            background-color: white;
            border: 2px dashed #ccc;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0; 
        }

        .area-jogo { /* Área de Jogo/Akinator */
            width: 350px; 
            background-color: #fafafa;
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-left: 1px solid #ddd;
        }

        /* ----------------------------------- */
        /* ESTILOS DE BLOCOS E PALETA */
        /* ----------------------------------- */
        .bloco {
            cursor: grab;
            font-weight: bold;
            font-size: 1em;
            color: white;
            min-width: 200px;
            padding: 8px 12px;
            margin-bottom: -1px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 10;
            border: none;
            clip-path: polygon(0 0, 100% 0, 100% 10px, 90% 10px, 90% 15px, 100% 15px, 100% 100%, 0 100%, 0 15px, 10% 15px, 10% 10px, 0 10px);
        }
        .bloco-paleta { margin-bottom: 20px; padding: 5px; background-color: rgba(255, 255, 255, 0.1); border-radius: 4px; }
        .bloco[data-type="pergunta"] { background-color: #00BCD4; border-color: #0097A7; }
        .bloco[data-type="palpite"] { background-color: #FF9800; border-color: #FB8C00; }
        .bloco[data-type="fim"] { background-color: #9E9E9E; border-color: #616161; }
        .bloco .input-pergunta-texto, .bloco .input-prop, .bloco input[type="number"] { padding: 4px; margin: 0 4px; border: 1px solid #ccc; border-radius: 3px; font-weight: bold; color: #333; text-align: center; }
        .bloco .input-pergunta-texto { width: 150px; }
        .bloco .input-prop { width: 100px; }
        .bloco .input-min-perguntas, .bloco .input-min-semelhanca { width: 40px; }
        .bloco.dragging { opacity: 0.8; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4); position: absolute; z-index: 1000; }

        /* ----------------------------------- */
        /* ESTILOS DO PAINEL DE VARIÁVEIS */
        /* ----------------------------------- */
        .personagem-box { background-color: #6A5ACD; border: 2px solid #5A2DCF; padding: 8px; border-radius: 6px; margin-bottom: 8px; text-align: left; font-size: 0.9em; }
        .propriedade-tag {
            background-color: #FFC107;
            color: #333;
            padding: 5px 10px;
            margin: 5px;
            display: inline-block;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .propriedade-tag:hover { background-color: #ff9800; }
        
        /* ----------------------------------- */
        /* MODAL (NOVO) */
        /* ----------------------------------- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none; /* Inicia oculto */
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 400px;
        }
        .modal-content label { display: block; margin: 8px 0; font-size: 1.1em; }
        .modal-content button { margin-top: 15px; }

        /* ----------------------------------- */
        /* ESTILOS DE JOGO (Mantidos) */
        /* ----------------------------------- */
        .palpite-box { background-color: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); min-height: 150px; margin-top: 20px; width: 90%; text-align: center; }
        .answer-buttons button { padding: 10px 20px; margin: 0 5px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        #btn-sim { background-color: #4CAF50; color: white; }
        #btn-nao { background-color: #f44336; color: white; }
        .highlight-current { border: 3px solid yellow !important; box-shadow: 0 0 15px yellow; }
    </style>
</head>
<body>
    <header class="top-bar">
        <a href="#" class="logo-link">
            <i class="fas fa-magic"></i> SIMULAB: AKINATOR DE BLOCOS
        </a>
    </header>

    <main class="simulador-container">
        
        <section class="painel-variaveis">
            
            <h2><i class="fas fa-users"></i> Personagens</h2>
            <div id="character-definitions">
                </div>
            <button onclick="addCharacter()" style="background-color: #4CAF50; color: white; padding: 5px 10px; border: none; border-radius: 4px; margin-top: 10px; width: 100%;">
                <i class="fas fa-plus"></i> Novo Personagem
            </button>
            
            <hr style="border-top: 1px solid #555; margin: 20px 0;">

            <h2><i class="fas fa-tags"></i> Propriedades</h2>
            <div id="property-list">
                </div>
            <button onclick="addProperty()" style="background-color: #FFA500; color: #333; padding: 5px 10px; border: none; border-radius: 4px; margin-top: 10px; width: 100%;">
                <i class="fas fa-plus"></i> Nova Propriedade
            </button>
        </section>


        <section class="painel-comandos">
            <h2><i class="fas fa-puzzle-piece"></i> Comandos</h2>
            
            <div class="bloco-paleta">
                <div class="bloco" draggable="true" data-type="pergunta" data-pergunta="Tem bigode?" data-prop="bigode">
                    Pergunta: <input type="text" class="input-pergunta-texto" value="Tem bigode?" onchange="updateBlockParam(this, 'pergunta-texto')">
                    Propriedade (ID): <input type="text" class="input-prop" value="bigode" onchange="updateBlockParam(this, 'prop')">
                    <p style="font-size: 0.7em; margin-top: 5px;">
                        * A resposta registra a característica do usuário.
                    </p>
                </div>
            </div>

            <div class="bloco-paleta">
                <div class="bloco" draggable="true" data-type="palpite" data-min-perguntas="5" data-min-semelhanca="90">
                    TENTAR PALPITE (Avançado)
                    <div style="font-size: 0.8em; margin-top: 5px; text-align: left;">
                        Mín. Perguntas: <input type="number" class="input-min-perguntas" value="5" min="1" onchange="updateBlockParam(this, 'min-perguntas')">
                        <br>
                        Mín. Semelhança (%): <input type="number" class="input-min-semelhanca" value="90" min="50" max="100" onchange="updateBlockParam(this, 'min-semelhanca')">
                    </div>
                </div>
            </div>

             <div class="bloco-paleta">
                <div class="bloco" draggable="true" data-type="fim">
                    FIM DA SEQUÊNCIA
                </div>
            </div>
        </section>

        <section class="area-sequencia">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h2><i class="fas fa-list-ol"></i> Sequência de Perguntas</h2>
                <button id="btn-iniciar-sequencia" onclick="startGame()" style="background-color: #1E90FF; color: white; padding: 8px 15px; border: none; border-radius: 4px;"><i class="fas fa-play"></i> INICIAR JOGO</button>
            </div>
            
            <div id="workspace" class="workspace">
                 <div id="start-block" class="bloco" data-type="inicio" style="background-color: #7A42F4; border-color: #5A2DCF; cursor: default;">
                    INÍCIO DO JOGO
                </div>
                </div>
        </section>

        <section class="area-jogo">
            <h2><i class="fas fa-user-secret"></i> Adivinhador</h2>
            
            <div id="palpite-box" class="palpite-box">
                <h3 id="game-question" style="font-size: 1.5em; font-weight: bold; color: #1E90FF;">Construa sua sequência de perguntas.</h3>
                
                <div id="game-status" style="min-height: 100px;">
                    </div>
                
                <div class="answer-buttons" style="margin-top: 20px;">
                    <button id="btn-sim" onclick="answer('sim')" disabled>SIM</button>
                    <button id="btn-nao" onclick="answer('nao')" disabled>NÃO</button>
                </div>
            </div>
            
            <button id="btn-reset" onclick="startGame()" style="margin-top: 20px;" disabled><i class="fas fa-redo"></i> REINICIAR</button>
        </section>

    </main>

    <div id="property-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modal-title">Gerenciar Propriedade:</h3>
            <div id="modal-character-list">
                </div>
            <button onclick="closePropertyModal()" style="background-color: #1E90FF; color: white; padding: 8px 15px; border: none; border-radius: 4px;"><i class="fas fa-check"></i> Fechar</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const painelComandos = document.querySelector('.painel-comandos');
            const workspace = document.getElementById('workspace');
            const gameQuestionEl = document.getElementById('game-question');
            const characterDefinitionsEl = document.getElementById('character-definitions');
            const propertyListEl = document.getElementById('property-list');
            const simBtn = document.getElementById('btn-sim');
            const naoBtn = document.getElementById('btn-nao');
            const btnReset = document.getElementById('btn-reset');
            const modalOverlay = document.getElementById('property-modal-overlay');
            const modalTitle = document.getElementById('modal-title');
            const modalCharList = document.getElementById('modal-character-list');

            // -----------------------------------
            // BANCO DE DADOS INICIAL E ESTADO
            // -----------------------------------
            
            // NOVO: Propriedades agora são um mapa central { 'id_propriedade': { 'char_id': boolean, ... } }
            let propertyMap = { 
                'bigode': { 'mario': true, 'batman': false, 'peach': false },
                'mulher': { 'mario': false, 'batman': false, 'peach': true },
                'capa': { 'mario': true, 'batman': true, 'peach': false },
            };
            
            // Personagens não possuem mais as propriedades diretamente
            let characterList = [ 
                { id: 'mario', name: "Super Mário" },
                { id: 'batman', name: "Batman" },
                { id: 'peach', name: "Princesa Peach" },
            ];
            
            let userHistory = {}; 
            let questionCount = 0; 

            let blockCounter = 3;
            let gameActive = false;
            let currentBlockIndex = 0;
            let commandSequence = []; 

            // Variáveis de estado para Drag and Drop e Backspace
            let draggedBlockType = null;
            let draggedClone = null;
            let dropTarget = null; 
            let activeDragBlockId = null; // ID do bloco que está sendo arrastado

            // --- FUNÇÕES DE GERENCIAMENTO DE PROPRIEDADES (NOVO) ---
            
            function renderProperties() {
                propertyListEl.innerHTML = Object.keys(propertyMap).map(propId => `
                    <span class="propriedade-tag" onclick="openPropertyModal('${propId}')">
                        ${propId}
                    </span>
                `).join('');
            }
            window.renderProperties = renderProperties;

            function addProperty() {
                const newProp = prompt("Digite o ID da nova propriedade (ex: e-robo). Use apenas letras e hífens:");
                if (newProp && newProp.trim() !== '') {
                    const cleanProp = newProp.trim().toLowerCase().replace(/[^a-z0-9-]/g, '');
                    if (!propertyMap[cleanProp]) {
                        propertyMap[cleanProp] = {};
                        // Inicializa a nova propriedade como false para todos os personagens existentes
                        characterList.forEach(char => {
                            propertyMap[cleanProp][char.id] = false;
                        });
                        renderProperties();
                        alert(`Propriedade '${cleanProp}' adicionada! Clique nela para definir os personagens.`);
                    } else {
                        alert("Essa propriedade já existe!");
                    }
                }
            }
            window.addProperty = addProperty;

            // Variável temporária para rastrear a propriedade que está sendo editada no modal
            let currentPropertyId = null;

            function openPropertyModal(propId) {
                currentPropertyId = propId;
                modalTitle.textContent = `Gerenciar Propriedade: ${propId}`;
                
                modalCharList.innerHTML = characterList.map(char => {
                    const isChecked = propertyMap[propId][char.id] || false;
                    return `
                        <label>
                            <input type="checkbox" 
                                data-char-id="${char.id}"
                                ${isChecked ? 'checked' : ''}
                                onchange="updateModalCheckbox('${propId}', '${char.id}', this.checked)">
                            ${char.name} (ID: ${char.id})
                        </label>
                    `;
                }).join('');
                
                modalOverlay.style.display = 'flex';
            }
            window.openPropertyModal = openPropertyModal;

            function updateModalCheckbox(propId, charId, isChecked) {
                if (propertyMap[propId]) {
                    propertyMap[propId][charId] = isChecked;
                }
                // O placar será atualizado ao fechar o modal ou ao iniciar o jogo
            }
            window.updateModalCheckbox = updateModalCheckbox;

            function closePropertyModal() {
                modalOverlay.style.display = 'none';
                currentPropertyId = null;
                // Re-renderiza o placar no painel de jogo (por garantia)
                updateScoreboard();
            }
            window.closePropertyModal = closePropertyModal;

            // --- FUNÇÕES DE GERENCIAMENTO DE PERSONAGENS ---

            function renderCharacters() {
                characterDefinitionsEl.innerHTML = characterList.map(char => `
                    <div class="personagem-box" data-char-id="${char.id}">
                        Nome: <input type="text" value="${char.name}" onchange="updateCharName('${char.id}', this.value)">
                        ID: <b>${char.id}</b>
                        <div style="margin-top: 5px; font-size: 0.8em;">
                            Total de Propriedades: ${Object.keys(propertyMap).length}
                        </div>
                    </div>
                `).join('');
            }

            function addCharacter() {
                blockCounter++;
                const newId = `char${blockCounter}`;
                characterList.push({ id: newId, name: `Novo Personagem ${blockCounter}` });
                
                // Inicializa o novo personagem com 'false' em todas as propriedades
                Object.keys(propertyMap).forEach(propId => {
                    propertyMap[propId][newId] = false;
                });

                renderCharacters();
                renderProperties();
            }
            window.addCharacter = addCharacter;

            function updateCharName(id, newName) {
                const char = characterList.find(c => c.id === id);
                if (char) char.name = newName;
                renderCharacters();
            }
            window.updateCharName = updateCharName;
            
            function updateBlockParam(inputElement, paramName) {
                const bloco = inputElement.closest('.bloco');
                if (bloco) {
                    if(paramName === 'pergunta-texto') {
                        bloco.setAttribute('data-pergunta', inputElement.value);
                    } else {
                        bloco.setAttribute(`data-${paramName}`, inputElement.value);
                    }
                }
            }
            window.updateBlockParam = updateBlockParam;

            // --- LÓGICA DE CÁLCULO DE SEMELHANÇA (REUSADA E AJUSTADA) ---
            
            function calculateSimilarity(characterId) {
                const answeredProps = Object.keys(userHistory);
                if (answeredProps.length === 0) return 0;

                let matches = 0;
                
                answeredProps.forEach(prop => {
                    const userValue = userHistory[prop];
                    const charValue = propertyMap[prop] ? propertyMap[prop][characterId] : false;
                    
                    if (userValue === charValue) {
                        matches++;
                    }
                });

                return Math.round((matches / answeredProps.length) * 100);
            }

            function updateScoreboard() {
                const gameStatusEl = document.getElementById('game-status');
                
                const scoredCharacters = characterList.map(char => ({
                    ...char,
                    similarity: calculateSimilarity(char.id)
                }));
                
                scoredCharacters.sort((a, b) => b.similarity - a.similarity);

                const scoreboardHTML = scoredCharacters.map((char, index) => {
                    const cor = index === 0 ? 'color: #FF4500; font-weight: bold;' : 'color: #555;';
                    return `<li style="${cor}">${index + 1}. ${char.name} (Semelhança: ${char.similarity}%)</li>`;
                }).join('');

                gameStatusEl.innerHTML = `
                    <p style="font-weight: bold; margin-bottom: 5px;">
                        PLACAR (Perguntas feitas: ${questionCount})
                    </p>
                    <ul style="list-style: none; padding: 0; text-align: left; font-size: 0.9em;">
                        ${scoreboardHTML}
                    </ul>
                `;
            }

            // --- LÓGICA DE INÍCIO E CONTROLE DO JOGO (Mantida) ---

            function updateCommandSequence() {
                commandSequence = Array.from(workspace.children)
                    .filter(el => el.getAttribute('data-type') !== 'inicio')
                    .map(el => el.id);
            }

            function startGame() {
                updateCommandSequence(); 

                if (commandSequence.length === 0) {
                     gameQuestionEl.textContent = "Adicione blocos de PERGUNTA e TENTAR PALPITE na sequência!";
                     return;
                }
                
                userHistory = {}; 
                questionCount = 0; 
                renderCharacters(); // Atualiza a lista de personagens (embora não mudem muito no jogo)
                gameActive = true;
                currentBlockIndex = 0;
                simBtn.disabled = false;
                naoBtn.disabled = false;
                btnReset.disabled = false;
                
                workspace.querySelectorAll('.bloco').forEach(b => b.classList.remove('highlight-current'));

                nextStep();
            }
            window.startGame = startGame;

            function nextStep() {
                if (!gameActive) return;

                workspace.querySelectorAll('.bloco').forEach(b => b.classList.remove('highlight-current'));
                
                if (currentBlockIndex >= commandSequence.length) {
                    endGame("Fim da sequência de comandos.", true);
                    return;
                }

                const currentBlockId = commandSequence[currentBlockIndex];
                const currentBlock = document.getElementById(currentBlockId);

                if (!currentBlock) {
                    endGame("Erro: Bloco ausente na sequência.", true);
                    return;
                }

                const type = currentBlock.getAttribute('data-type');
                currentBlock.classList.add('highlight-current');

                if (type === 'pergunta') {
                    const questionText = currentBlock.getAttribute('data-pergunta') || "Pergunta não definida?";
                    gameQuestionEl.textContent = `PERGUNTA: ${questionText}`;
                    
                } else if (type === 'palpite') {
                    
                    const minQuestions = parseInt(currentBlock.getAttribute('data-min-perguntas')) || 1;
                    const minSimilarity = parseInt(currentBlock.getAttribute('data-min-semelhanca')) || 90;
                    
                    gameQuestionEl.textContent = `VERIFICANDO CONDIÇÕES: Perguntas: ${questionCount}/${minQuestions}. Semelhança: Mín. ${minSimilarity}%`;
                    
                    if (questionCount < minQuestions) {
                         gameQuestionEl.textContent = `CRITÉRIO 1 FALHOU: Apenas ${questionCount} perguntas. Mínimo de ${minQuestions}.`;
                         currentBlockIndex++; 
                         setTimeout(nextStep, 1500);
                         return;
                    }
                    
                    let bestMatch = null;
                    let highestSimilarity = 0;

                    characterList.forEach(char => {
                        const similarity = calculateSimilarity(char.id);
                        if (similarity >= minSimilarity && similarity > highestSimilarity) {
                            bestMatch = char;
                            highestSimilarity = similarity;
                        }
                    });
                    
                    if (bestMatch) {
                        endGame(`ACERTEI! O personagem é: ${bestMatch.name}! (${highestSimilarity}% de certeza)`, false);
                    } else {
                        gameQuestionEl.textContent = `NENHUM PALPITE ACIMA DE ${minSimilarity}%. Máximo encontrado: ${highestSimilarity}%. Continue a sequência.`;
                        currentBlockIndex++; 
                        setTimeout(nextStep, 1500); 
                    }
                } else if (type === 'fim') {
                    endGame("Sequência de Comandos Encerrada.", true);
                }
            }

            window.answer = (response) => {
                if (!gameActive) return;

                const currentBlockId = commandSequence[currentBlockIndex];
                const currentBlock = document.getElementById(currentBlockId);
                const type = currentBlock.getAttribute('data-type');
                
                if (type === 'pergunta') {
                    
                    const propQuestion = currentBlock.getAttribute('data-prop')?.toLowerCase();
                    
                    if (!propertyMap[propQuestion]) {
                        alert(`Erro de programação: Propriedade '${propQuestion}' inválida ou não definida. Avance o bloco.`);
                    } else {
                        // Registra a resposta do usuário no histórico
                        userHistory[propQuestion] = (response === 'sim');
                        questionCount++;
                    }

                    updateScoreboard(); 
                    currentBlockIndex++;
                    nextStep();
                }
            };
            
            function endGame(message, isError) {
                gameActive = false;
                simBtn.disabled = true;
                naoBtn.disabled = true;
                
                gameQuestionEl.style.color = isError ? '#f44336' : '#4CAF50';
                gameQuestionEl.textContent = message;
                
                workspace.querySelectorAll('.bloco').forEach(b => b.classList.remove('highlight-current'));
            }

            // --- FUNÇÕES DE DRAG AND DROP E DELEÇÃO (ATUALIZADO) ---

            function createNewBlock(type) {
                blockCounter++;
                const newId = `bloco-${blockCounter}`;
                const originalBlock = painelComandos.querySelector(`.bloco[data-type="${type}"]`);
                const clone = originalBlock.cloneNode(true);
                
                clone.id = newId;
                clone.setAttribute('draggable', 'true');
                
                const dataAttributes = originalBlock.dataset;
                for (const key in dataAttributes) {
                    if (key !== 'type') {
                        clone.setAttribute(`data-${key}`, dataAttributes[key]);
                    }
                }
                
                clone.querySelectorAll('input').forEach(inputEl => {
                    inputEl.addEventListener('dragstart', (e) => e.stopPropagation());
                    const paramName = inputEl.className.match(/input-(.+)/)[1];
                    inputEl.onchange = () => updateBlockParam(inputEl, paramName);
                });

                return clone;
            };

            // DRAG START para Paleta
            painelComandos.querySelectorAll('.bloco').forEach(bloco => {
                bloco.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    draggedBlockType = bloco.getAttribute('data-type');
                    
                    draggedClone = createNewBlock(draggedBlockType);
                    draggedClone.classList.add('dragging');
                    draggedClone.style.pointerEvents = 'none';
                    document.body.appendChild(draggedClone);
                    
                    activeDragBlockId = draggedClone.id; // Define o bloco ativo (para deleção)
                    
                    updateClonePosition(e);
                });
            });

            // DRAG START para Workspace
            workspace.addEventListener('dragstart', (e) => {
                const target = e.target.closest('.bloco');
                if (target && target.id !== 'start-block') {
                    e.stopPropagation();
                    
                    draggedClone = target;
                    draggedClone.classList.add('dragging');
                    activeDragBlockId = draggedClone.id; // Define o bloco ativo (para deleção)
                    
                    const rect = target.getBoundingClientRect();
                    
                    draggedClone.offsetX = e.clientX - rect.left;
                    draggedClone.offsetY = e.clientY - rect.top;
                    
                    target.remove();
                    document.body.appendChild(draggedClone);
                    
                    updateClonePosition(e);
                    
                    updateCommandSequence();
                }
            });

            // DRAG OVER / DRAG LEAVE / DRAG END (Mantidos)
            document.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedClone) {
                    updateClonePosition(e);
                    const targetElement = e.target.closest('.bloco, #workspace');
                    if (targetElement) {
                        handleHoverEffect(targetElement, e);
                    } else {
                        clearHoverEffect();
                    }
                }
            });

            document.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedClone && dropTarget) {
                    
                    const newBlock = createNewBlock(draggedClone.getAttribute('data-type'));
                    newBlock.id = draggedClone.id;
                    newBlock.style.position = 'static'; 

                    if (dropTarget.id === 'workspace') {
                        workspace.appendChild(newBlock);
                    } else {
                        workspace.insertBefore(newBlock, dropTarget.nextElementSibling);
                    }
                    
                    updateCommandSequence();
                }
                
                cleanupDrag();
            });

            document.addEventListener('dragend', () => {
                cleanupDrag();
            });

            // --- DELEÇÃO POR BACKSPACE (NOVO) ---
            window.onkeydown = function(e) {
                // KeyCode 8 é o Backspace/Delete (em alguns navegadores)
                if (e.keyCode === 8) { 
                    // Verifica se há um bloco ativo sendo arrastado e o remove
                    if (activeDragBlockId && draggedClone) {
                        e.preventDefault(); // Impede o navegador de voltar para a página anterior
                        
                        // Remove o clone (que é o bloco que o usuário está segurando)
                        draggedClone.remove();
                        
                        // Limpa o estado
                        cleanupDrag(); 
                        updateCommandSequence();
                        alert(`Bloco ${activeDragBlockId} deletado com Backspace.`);
                    }
                }
            };


            // --- FUNÇÕES AUXILIARES DE DRAG ---

            function updateClonePosition(e) {
                 if (draggedClone) {
                    const x = e.clientX - (draggedClone.offsetX || 0);
                    const y = e.clientY - (draggedClone.offsetY || 0);
                    draggedClone.style.left = x + 'px';
                    draggedClone.style.top = y + 'px';
                }
            }

            function handleHoverEffect(targetElement, e) {
                clearHoverEffect();
                
                if (targetElement.id === 'start-block') {
                    dropTarget = document.getElementById('start-block'); 
                    dropTarget.style.marginBottom = '10px';
                    return;
                }
                
                if (targetElement.id === 'workspace') {
                    const lastBlock = workspace.lastElementChild;
                    dropTarget = lastBlock;
                    if(dropTarget) dropTarget.style.marginBottom = '10px';
                    return;
                }
                
                const targetRect = targetElement.getBoundingClientRect();
                
                if (e.clientY > targetRect.top + targetRect.height / 2) {
                    dropTarget = targetElement;
                    dropTarget.style.marginBottom = '10px';
                } else {
                    const prevBlock = targetElement.previousElementSibling;
                    dropTarget = prevBlock;
                    if(prevBlock && prevBlock.id !== 'start-block') {
                         prevBlock.style.marginBottom = '10px';
                    } else if (!prevBlock) {
                         document.getElementById('start-block').style.marginBottom = '10px';
                    }
                }
            }

            function clearHoverEffect() {
                workspace.querySelectorAll('.bloco').forEach(b => {
                    b.style.marginBottom = '0px'; 
                });
                dropTarget = null;
            }

            function cleanupDrag() {
                if (draggedClone) {
                    draggedClone.remove();
                }
                draggedBlockType = null;
                draggedClone = null;
                dropTarget = null;
                activeDragBlockId = null; // Limpa o ID do bloco ativo
                clearHoverEffect();
            }

            // Inicialização
            renderCharacters(); 
            renderProperties();
        });
    </script>
</body>
</html>
