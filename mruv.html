<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRUV - Movimento Retilíneo Uniformemente Variado</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Variável de largura da sidebar */
        :root {
            --sidebar-width: 300px;
            --header-height: 55px;
        }

        /* --- ESTILOS DO HEADER --- */
        .top-bar {
            background-color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 0;
            height: var(--header-height); 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100; 
            display: flex;
            align-items: stretch; 
            border-bottom: 1px solid #ddd; 
            box-sizing: border-box; 
        }

        .logo-link {
            text-decoration: none;
            color: #D2691E; 
            font-size: 18px;
            font-weight: bold;
            padding: 0 25px; 
            display: flex;
            align-items: center; 
            border-right: 1px solid #ddd; 
            transition: background-color 0.3s;
        }
        
        .logo-link:hover {
            background-color: #f5f5f5;
        }

        .nav-buttons {
            display: flex;
            justify-content: flex-start;
            flex-grow: 1;
        }

        .page-title {
            padding: 0 25px;
            font-size: 16px;
            font-weight: bold;
            color: #555;
            display: flex;
            align-items: center;
        }

        /* --- ESTILOS GERAIS DO BODY --- */
        body {
            background-color: #f0f8ff;
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: sans-serif;
            padding-top: var(--header-height); 
            overflow: hidden; 
        }

        /* --- ESTILO DO PAINEL DE CONTROLE (SIDEBAR) --- */
        #inputPanel {
            position: fixed;
            top: var(--header-height); 
            left: 0;
            width: var(--sidebar-width); 
            height: calc(100vh - var(--header-height)); 
            background-color: white;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); 
            padding: 15px; 
            box-sizing: border-box;
            z-index: 10;
            
            display: flex;
            flex-direction: column;
            overflow-y: auto; 
        }

        /* --- SELETORES DE MODO --- */
        .mode-selector-group {
            display: flex;
            flex-wrap: wrap; 
            margin-bottom: 15px;
            border: 1px solid #008CBA;
            border-radius: 5px;
            overflow: hidden;
        }

        .mode-selector {
            width: 50%; 
            padding: 8px 5px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            background-color: white;
            color: #008CBA;
            transition: background-color 0.2s, color 0.2s;
            box-sizing: border-box;
            border-bottom: 1px solid #008CBA;
        }
        
        .mode-selector:nth-child(even) {
            border-right: none;
            border-left: 1px solid #008CBA;
        }
        .mode-selector:nth-child(odd) {
            border-right: 1px solid #008CBA;
        }
        .mode-selector:nth-last-child(-n+2) {
            border-bottom: none;
        }

        .mode-selector.active {
            background-color: #008CBA;
            color: white;
        }
        
        .mode-selector:not(.active):hover {
            background-color: #e0f7ff;
        }
        
        /* --- GRUPOS DE INPUTS --- */
        .input-group-container {
            display: flex;
            flex-direction: column; 
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-group {
            width: 100%; 
        }
        
        .dataInput {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        /* Estilo do resultado na sidebar */
        #resultado {
            margin-top: 5px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
            min-height: 40px;
            color: #333;
        }
        
        .formula {
            font-style: italic;
            font-family: serif;
            font-size: 1.1em;
            color: #333;
            margin-left: 15px; 
            line-height: 1.5;
        }
        
        .label {
            font-size: 12px;
            margin-bottom: 4px;
            color: #555;
            font-weight: bold;
            display: block; 
        }

        /* --- ESTILOS DO PLANO CARTESIANO (ÁREA DE VISUALIZAÇÃO) --- */
        #planoCartesiano {
            position: fixed;
            top: var(--header-height); 
            left: var(--sidebar-width); 
            width: calc(100% - var(--sidebar-width)); 
            height: calc(100vh - var(--header-height)); 
            background-color: white; 
            z-index: -1; 
            
            /* Criação do Grid - Será ajustado via JS para o zoom */
            background-size: 25px 25px; 
            background-image: 
                linear-gradient(to right, lightblue 1px, transparent 1px),
                linear-gradient(to bottom, lightblue 1px, transparent 1px);
            
            background-position: 50% 50%; /* Centro */
        }

        /* Criação do eixo x (horizontal) - NO CENTRO VERTICAL */
        #planoCartesiano::before {
            content: '';
            position: absolute;
            top: 50%; 
            transform: translateY(-50%); 
            left: 0;
            width: 100%;
            height: 2px;
            background-color: red; 
        }

        /* Criação do eixo y (vertical no centro) */
        #planoCartesiano::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 100%;
            background-color: red; 
        }

        /* --- ESTILOS DO CORPO / OBJETO --- */
        #corpo {
            position: absolute;
            top: 50%; 
            transform: translateY(-50%); 
            width: 20px;
            height: 20px;
            background-color: black;
            border-radius: 50%;
            z-index: 5;
            cursor: grab; 
            transition: left 0s linear; 
        }
        
        #corpo:active {
            cursor: grabbing;
        }
        
        /* Balão de Velocidade/Aceleração */
        #speedDisplay {
            position: absolute;
            bottom: 100%; 
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            padding: 3px 6px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 12px;
            border-radius: 3px;
            pointer-events: none; 
            opacity: 0; 
            transition: opacity 0.1s;
            text-align: center;
            line-height: 1.2;
        }
        
        /* Estilos dos botões */
        .action-button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            flex-grow: 1;
        }

        #startStopButton {
            background-color: #4CAF50;
            color: white;
        }

        #startStopButton:hover:not(:disabled) {
            background-color: #45a049;
        }
        
        #startStopButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #resetButton {
            background-color: #f44336;
            color: white;
        }

        #resetButton:hover {
            background-color: #da190b;
        }
    </style>
</head>
<body>
    <header class="top-bar">
        <a href="index.html" class="logo-link">
            <i class="fas fa-book-reader"></i> PLATAFORMA
        </a>
        <div class="nav-buttons">
            <span class="page-title">MRUV - MOVIMENTO RETILÍNEO UNIFORMEMENTE VARIADO</span>
        </div>
    </header>
    
    <div id="planoCartesiano"></div>

    <div id="inputPanel">
        <div class="mode-selector-group">
            <div class="mode-selector active" data-mode="simulacao">Simulação</div>
            <div class="mode-selector" data-mode="posicao">Calcular Posição (S)</div>
            <div class="mode-selector" data-mode="velocidade">Calcular Velocidade (V)</div>
            <div class="mode-selector" data-mode="aceleracao">Calcular Aceleração (a)</div>
        </div>
        
        <div id="resultado">Pronto para simular **MRUV (S = S₀ + V₀t + at²/2)**. Arraste a bola para definir S₀.</div>
        
        <div class="input-group-container">
            <div class="input-group" data-input-group="s-start">
                <label class="label">Posição Inicial (S₀) (m) - **ARRASTE A BOLA**</label>
                <input type="number" id="sStart" class="dataInput" value="0">
            </div>
            <div class="input-group" data-input-group="s-end" style="display: none;">
                <label class="label">Posição Final (S) (m)</label>
                <input type="number" id="sEnd" class="dataInput" value="10">
            </div>
            <div class="input-group" data-input-group="v0">
                <label class="label">V. Inicial (V₀) (m/s)</label>
                <input type="number" id="vStart" class="dataInput" value="1">
            </div>
            <div class="input-group" data-input-group="v-end" style="display: none;">
                <label class="label">V. Final (V) (m/s)</label>
                <input type="number" id="vEnd" class="dataInput" value="10">
            </div>
            <div class="input-group" data-input-group="a">
                <label class="label">Aceleração (a) (m/s²)</label>
                <input type="number" id="aceleracao" class="dataInput" value="0.2">
            </div>
            <div class="input-group" data-input-group="t-end">
                <label class="label">Tempo Final (t) (s)</label>
                <input type="number" id="tEnd" class="dataInput" value="10">
            </div>
        </div>
        
        <div class="button-row">
            <button id="startStopButton" class="action-button">Iniciar Simulação</button>
            <button id="resetButton" class="action-button">Resetar</button>
        </div>
    </div>
    
    <div id="corpo">
        <div id="speedDisplay"></div>
    </div>

    <script>
        class CalculadoraMRUV {
            constructor() {
                // Constantes e Escala de Zoom
                this.SIDEBAR_WIDTH = 300; 
                this.CORPO_WIDTH = 20; 
                this.TAMANHO_CELULA_INICIAL = 25;
                this.TAMANHO_CELULA = this.TAMANHO_CELULA_INICIAL; // 25px por unidade (metro)
                this.MIN_TAMANHO_CELULA = 5; // Máximo zoom out (deszoom)
                this.MAX_TAMANHO_CELULA = 50; // Máximo zoom in
                this.MAX_T_ANIMACAO = 60; 

                // Elementos DOM
                this.corpo = document.getElementById('corpo');
                this.planoCartesiano = document.getElementById('planoCartesiano');
                this.speedDisplay = document.getElementById('speedDisplay');
                this.sStartInput = document.getElementById('sStart');
                this.sEndInput = document.getElementById('sEnd');
                this.vStartInput = document.getElementById('vStart');
                this.vEndInput = document.getElementById('vEnd');
                this.aceleracaoInput = document.getElementById('aceleracao');
                this.tEndInput = document.getElementById('tEnd');    
                this.resultadoDiv = document.getElementById('resultado');
                this.actionButton = document.getElementById('startStopButton'); 
                this.resetButton = document.getElementById('resetButton');
                this.modeSelectors = document.querySelectorAll('.mode-selector');
                
                // Variáveis de estado
                this.animacaoID = null;
                this.tempoInicialAnimacao = 0;
                this.isSimulando = false;
                this.isDemonstracao = false; 
                this.tempoLimiteDemonstracao = null;
                this.modoAtual = 'simulacao'; 
                this.isDragging = false; 
                
                this.corpoData = {
                    posicaoInicial: 0,
                    velocidadeInicial: 0,
                    aceleracao: 0,
                    tempoTotal: 0
                };
                
                this.configurarListeners();
                this.setMode('simulacao');
                this.resetarSimulacao();
            }

            // --- AUXILIAR DE PARSING ---
            
            _parseInput(inputElement) {
                if (!inputElement || inputElement.value === '') return NaN;
                return parseFloat(inputElement.value.replace(',', '.'));
            }
            
            // --- CONVERSÃO DE COORDENADAS ---
            
            posicaoToX(s) {
                const canvasWidth = window.innerWidth - this.SIDEBAR_WIDTH; 
                const centroX_canvas = canvasWidth / 2;
                // A posição em pixels é dada pela posição em metros * o tamanho atual da célula
                const offsetX_movimento = s * this.TAMANHO_CELULA; 
                return this.SIDEBAR_WIDTH + centroX_canvas + offsetX_movimento - (this.CORPO_WIDTH / 2); 
            }
            
            xToPosicao(x_tela) {
                const canvasWidth = window.innerWidth - this.SIDEBAR_WIDTH; 
                const centroX_canvas = canvasWidth / 2;
                const offsetX_movimento = x_tela - this.SIDEBAR_WIDTH - centroX_canvas + (this.CORPO_WIDTH / 2);
                return offsetX_movimento / this.TAMANHO_CELULA;
            }

            getCurrentPosition() {
                // Retorna a posição atual da simulação ou a posição S₀ se estiver parado
                if (this.isSimulando) {
                    const S0 = this.corpoData.posicaoInicial;
                    const V0 = this.corpoData.velocidadeInicial;
                    const A = this.corpoData.aceleracao;
                    const t = this.corpoData.tempoTotal;
                    // S = S0 + V0*t + (A*t^2)/2
                    return S0 + V0 * t + (A * Math.pow(t, 2) / 2);
                } else {
                    return this._parseInput(this.sStartInput) || 0;
                }
            }


            // --- LÓGICA DE ARRASTAR O CORPO ---
            
            startDrag(e) {
                if (this.isSimulando || this.modoAtual !== 'simulacao') return;
                
                e.preventDefault();
                this.isDragging = true;
                this.corpo.style.cursor = 'grabbing';
            }

            drag(e) {
                if (!this.isDragging) return;
                
                let clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let newXPos = clientX;
                let newS = this.xToPosicao(newXPos);
                
                newS = Math.round(newS * 4) / 4; // Arredonda para 0.25 unidades
                
                this.sStartInput.value = newS.toFixed(2);
                this.corpoData.posicaoInicial = newS;
                this.atualizaPosicaoCorpo(newS);
                
                this.resultadoDiv.innerHTML = `**S₀** definida em **${newS.toFixed(2)}m** (Arraste e solte).`;
            }

            stopDrag() {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.corpo.style.cursor = 'grab';
                    this.resetarSimulacao();
                }
            }

            // --- LÓGICA DE ZOOM POR SCROLL ---
            handleZoom(e) {
                // Impede o scroll padrão da página
                e.preventDefault(); 
                
                // Ignora o scroll se estiver na sidebar
                if (e.clientX < this.SIDEBAR_WIDTH) return;
                
                const zoomFactor = 1.1; // Fator de zoom (10% por passo)
                
                // Zoom in (deltaY < 0, geralmente scroll para cima)
                if (e.deltaY < 0) {
                    this.TAMANHO_CELULA *= zoomFactor;
                } 
                // Zoom out (deltaY > 0, geralmente scroll para baixo)
                else if (e.deltaY > 0) {
                    this.TAMANHO_CELULA /= zoomFactor;
                }

                // Limites de zoom
                if (this.TAMANHO_CELULA > this.MAX_TAMANHO_CELULA) {
                    this.TAMANHO_CELULA = this.MAX_TAMANHO_CELULA;
                } else if (this.TAMANHO_CELULA < this.MIN_TAMANHO_CELULA) {
                    this.TAMANHO_CELULA = this.MIN_TAMANHO_CELULA;
                }
                
                // Atualiza o visual da grade (background-size)
                this.planoCartesiano.style.backgroundSize = `${this.TAMANHO_CELULA}px ${this.TAMANHO_CELULA}px`;
                
                // Recalcula a posição da bola com o novo zoom
                this.atualizaPosicaoCorpo(this.getCurrentPosition());
            }

            // --- CONFIGURAÇÃO DE LISTENERS ---
            
            configurarListeners() {
                this.resetButton.addEventListener('click', () => this.resetarSimulacao());
                this.actionButton.addEventListener('click', () => {
                    if (this.isDemonstracao) return; 

                    if (this.modoAtual === 'simulacao') {
                        this.toggleSimulacao();
                    } else {
                        this.handleOperacoes(this.modoAtual);
                    }
                });
                this.modeSelectors.forEach(selector => {
                    selector.addEventListener('click', (e) => {
                        this.setMode(e.target.getAttribute('data-mode'));
                    });
                });
                
                // Inputs que reconfiguram a simulação
                [this.sStartInput, this.vStartInput, this.aceleracaoInput, this.tEndInput].forEach(input => {
                    input.addEventListener('change', () => {
                         this.resetarSimulacao();
                    });
                });
                
                // LISTENERS DE INTERAÇÃO (Arrastar e Zoom)
                this.corpo.addEventListener('mousedown', (e) => this.startDrag(e));
                this.corpo.addEventListener('touchstart', (e) => this.startDrag(e));
                window.addEventListener('mousemove', (e) => this.drag(e));
                window.addEventListener('touchmove', (e) => this.drag(e));
                window.addEventListener('mouseup', () => this.stopDrag());
                window.addEventListener('touchend', () => this.stopDrag());
                
                // Listener para o zoom
                window.addEventListener('wheel', (e) => this.handleZoom(e), { passive: false });
            }

            // --- LÓGICA DE MUDANÇA DE MODO ---

            setMode(novoModo) {
                this.stopSimulacao(); 
                this.modoAtual = novoModo;
                
                this.modeSelectors.forEach(selector => {
                    selector.classList.remove('active');
                    if (selector.getAttribute('data-mode') === novoModo) {
                        selector.classList.add('active');
                    }
                });

                this.configurarInputs(novoModo);
                
                const isSimulacao = novoModo === 'simulacao';
                this.actionButton.textContent = isSimulacao ? 'Iniciar Simulação' : 'Calcular e Simular';
                this.actionButton.style.backgroundColor = isSimulacao ? '#4CAF50' : '#008CBA';
                
                this.resetarSimulacao();
            }

            getModeName(modo) {
                switch(modo) {
                    case 'simulacao': return 'Simulação';
                    case 'posicao': return 'Posição (S)';
                    case 'velocidade': return 'Velocidade (V)';
                    case 'aceleracao': return 'Aceleração (a)';
                    default: return '';
                }
            }
            
            // --- LÓGICA DE SIMULAÇÃO/ANIMAÇÃO UNIFICADA ---

            resetarSimulacao() {
                this.stopSimulacao();
                this.actionButton.textContent = (this.modoAtual === 'simulacao') ? 'Iniciar Simulação' : 'Calcular e Simular';
                this.actionButton.style.backgroundColor = (this.modoAtual === 'simulacao') ? '#4CAF50' : '#008CBA';
                this.actionButton.disabled = false;
                
                this.corpoData.posicaoInicial = this._parseInput(this.sStartInput) || 0;
                this.corpoData.velocidadeInicial = this._parseInput(this.vStartInput) || 0;
                this.corpoData.aceleracao = this._parseInput(this.aceleracaoInput) || 0;
                this.corpoData.tempoTotal = 0; 
                
                this.isDemonstracao = false;
                this.tempoLimiteDemonstracao = null;

                this.atualizaPosicaoCorpo(this.corpoData.posicaoInicial); 
                this.hideSpeedDisplay();
                
                if (this.modoAtual === 'simulacao') {
                    this.resultadoDiv.innerHTML = `Pronto para simular **MRUV (S = S₀ + V₀t + at²/2)**. Arraste a bola para definir S₀.`;
                } else {
                     this.resultadoDiv.innerHTML = `Pronto para calcular **${this.getModeName(this.modoAtual)}**. Clique em 'Calcular e Simular'.`;
                }
            }

            toggleSimulacao() {
                if (this.isSimulando) {
                    this.stopSimulacao();
                    this.actionButton.textContent = 'Continuar Simulação';
                    this.actionButton.style.backgroundColor = '#f39c12';
                    this.hideSpeedDisplay();
                } else {
                    this.iniciarSimulacao();
                }
            }

            iniciarSimulacao() {
                if (this.isSimulando) return;
                
                const tEnd = this._parseInput(this.tEndInput);
                if (isNaN(tEnd) || tEnd <= 0) {
                     this.resultadoDiv.innerHTML = '<span style="color: red; font-weight: bold;">ERRO:</span> Insira um Tempo Final (t) válido e positivo.';
                     return;
                }

                this.corpoData.posicaoInicial = this._parseInput(this.sStartInput) || 0;
                this.corpoData.velocidadeInicial = this._parseInput(this.vStartInput) || 0;
                this.corpoData.aceleracao = this._parseInput(this.aceleracaoInput) || 0;

                this.isSimulando = true;
                this.actionButton.textContent = 'Parar Simulação';
                this.actionButton.style.backgroundColor = '#4CAF50';
                
                this.tempoInicialAnimacao = performance.now() - (this.corpoData.tempoTotal * 1000); 
                
                this.animacaoID = requestAnimationFrame(this.loopAnimacao.bind(this));
            }

            stopSimulacao() {
                if (this.animacaoID) {
                    cancelAnimationFrame(this.animacaoID);
                }
                this.isSimulando = false;
                this.isDemonstracao = false;
                this.hideSpeedDisplay();
            }

            loopAnimacao(timestamp) {
                if (!this.isSimulando) return;
                
                const S0 = this.corpoData.posicaoInicial;
                const V0 = this.corpoData.velocidadeInicial;
                const A = this.corpoData.aceleracao;
                const tempoLimiteGlobal = this._parseInput(this.tEndInput); 
                
                const tempoDecorridoReal = (timestamp - this.tempoInicialAnimacao) / 1000; 
                
                let t_simulacao = tempoDecorridoReal;
                let deveParar = false;

                let tempoLimite = this.isDemonstracao ? this.tempoLimiteDemonstracao : tempoLimiteGlobal;

                if (!isNaN(tempoLimite) && tempoLimite > 0) {
                    if (t_simulacao >= tempoLimite) {
                        t_simulacao = tempoLimite;
                        deveParar = true;
                    }
                }

                this.corpoData.tempoTotal = t_simulacao;

                // Fórmulas do MRUV
                const S_atual = S0 + V0 * t_simulacao + (A * Math.pow(t_simulacao, 2) / 2);
                const V_atual = V0 + A * t_simulacao;
                const tAtual = t_simulacao;

                this.atualizaPosicaoCorpo(S_atual);
                this.atualizaResultadoAnimacao(S0, V0, A, tAtual, S_atual, V_atual);
                this.showSpeedDisplay(V_atual, A);
                

                if (deveParar) {
                    this.stopSimulacao();
                    
                    if (this.isDemonstracao) {
                        this.actionButton.textContent = 'Demonstração Concluída';
                        this.actionButton.style.backgroundColor = '#007bb5'; 
                    } else {
                        this.actionButton.textContent = 'Simulação Concluída';
                        this.actionButton.style.backgroundColor = '#007bb5'; 
                    }
                    this.actionButton.disabled = false;
                    this.hideSpeedDisplay();

                } else {
                    this.animacaoID = requestAnimationFrame(this.loopAnimacao.bind(this));
                }
            }
            
            // --- ATUALIZAÇÃO VISUAL (Corpo e Resultados) ---
            
            showSpeedDisplay(V, A) {
                this.speedDisplay.innerHTML = `V: ${V.toFixed(2)} m/s <br> a: ${A.toFixed(2)} m/s²`;
                this.speedDisplay.style.opacity = 1;
            }
            
            hideSpeedDisplay() {
                 this.speedDisplay.style.opacity = 0;
            }

            atualizaPosicaoCorpo(s) {
                this.corpo.style.left = `${this.posicaoToX(s)}px`;
            }

            atualizaResultadoAnimacao(S0, V0, A, t, S, V) {
                this.resultadoDiv.innerHTML = `
                    **${this.isDemonstracao ? 'DEMONSTRAÇÃO' : 'SIMULAÇÃO'} MRUV:** <br>
                    <p style="margin: 5px 0 0 0;">Posição (S):</p>
                    <p class="formula">S = ${S0.toFixed(2)} + ${V0.toFixed(2)}·${t.toFixed(2)} + ${A.toFixed(2)}·(${t.toFixed(2)})²/2</p>
                    <hr style="border-color: #eee; margin: 5px 0;">
                    <p style="font-weight: bold; color: #4CAF50;">S = ${S.toFixed(2)}m &nbsp;|&nbsp; V = ${V.toFixed(2)}m/s &nbsp;|&nbsp; t = ${t.toFixed(2)}s</p>
                `;
            }

            iniciarDemonstracaoCalculo(S0, V0, A, T_final) {
                this.corpoData.posicaoInicial = S0;
                this.corpoData.velocidadeInicial = V0;
                this.corpoData.aceleracao = A;
                this.corpoData.tempoTotal = 0; 
                
                this.tempoLimiteDemonstracao = T_final; 
                this.isDemonstracao = true;
                
                this.isSimulando = true;
                this.actionButton.textContent = 'Demonstrando...';
                this.actionButton.style.backgroundColor = '#f39c12';
                this.actionButton.disabled = true;

                this.tempoInicialAnimacao = performance.now();
                this.animacaoID = requestAnimationFrame(this.loopAnimacao.bind(this));
            }


            // --- FUNÇÕES DE CÁLCULO ---

            handleOperacoes(modoCalculo) {
                this.stopSimulacao();
                
                try {
                    const S0 = this._parseInput(this.sStartInput);
                    const S_final = this._parseInput(this.sEndInput);
                    const V0 = this._parseInput(this.vStartInput);
                    const V_final = this._parseInput(this.vEndInput);
                    const A_input = this._parseInput(this.aceleracaoInput);
                    const T_final_input = this._parseInput(this.tEndInput);

                    let output = `<h4 style="color: #008CBA; margin: 0 0 5px 0;">Cálculo de ${this.getModeName(modoCalculo)}:</h4>`;

                    let S0_demo = S0;
                    let V0_demo = V0;
                    let A_demo = A_input;
                    let T_demo = T_final_input;

                    if (isNaN(S0) || isNaN(V0) || isNaN(T_final_input) && modoCalculo !== 'aceleracao') {
                         throw new Error("Posição Inicial (S₀), V. Inicial (V₀) e Tempo Final (t) são obrigatórios neste modo.");
                    }
                    if (modoCalculo !== 'simulacao' && T_final_input <= 0) {
                         throw new Error("O Tempo (t) deve ser positivo para o cálculo.");
                    }
                    if (T_final_input > this.MAX_T_ANIMACAO) {
                         throw new Error(`O tempo máximo para simulação é ${this.MAX_T_ANIMACAO}s.`);
                    }

                    if (modoCalculo === 'posicao') {
                        // CÁLCULO DE POSIÇÃO (S = S₀ + V₀t + at²/2)
                        const A = A_input;
                        const t = T_final_input;
                        
                        const S_calc = S0 + V0 * t + (A * Math.pow(t, 2) / 2);
                        
                        output += `
                            <p style="margin: 10px 0 0 0;">**S = S₀ + V₀t + at²/2**</p>
                            <p class="formula">S = ${S0.toFixed(2)} + ${V0.toFixed(2)}·${t.toFixed(2)} + ${A.toFixed(2)}·(${t.toFixed(2)})²/2</p>
                            <hr style="border-color: #ddd; margin: 5px 0;">
                            <p style="font-size: 1.2em; color: #4CAF50; font-weight: bold;">S = ${S_calc.toFixed(2)} m</p>
                        `;

                    } else if (modoCalculo === 'velocidade') {
                        // CÁLCULO DE VELOCIDADE (V = V₀ + at)
                        if (isNaN(A_input) || isNaN(T_final_input)) throw new Error("Preencha Aceleração (a) e Tempo (t).");
                        
                        const A = A_input;
                        const t = T_final_input;

                        const V_calc = V0 + A * t;
                        
                        output += `
                            <p style="margin: 10px 0 0 0;">**V = V₀ + at**</p>
                            <p class="formula">V = ${V0.toFixed(2)} + ${A.toFixed(2)} · ${t.toFixed(2)}</p>
                            <hr style="border-color: #ddd; margin: 5px 0;">
                            <p style="font-size: 1.2em; color: #4CAF50; font-weight: bold;">V = ${V_calc.toFixed(2)} m/s</p>
                        `;

                        this.vEndInput.value = V_calc.toFixed(2);
                        
                    } else if (modoCalculo === 'aceleracao') {
                        // CÁLCULO DE ACELERAÇÃO (a = (V - V₀) / t)
                        if (isNaN(V_final) || isNaN(T_final_input)) throw new Error("Preencha Velocidade Final (V) e Tempo (t).");
                        
                        const t = T_final_input;

                        const A_calc = (V_final - V0) / t;
                        
                        output += `
                            <p style="margin: 10px 0 0 0;">**a = (V - V₀) / t**</p>
                            <p class="formula">a = (${V_final.toFixed(2)} - ${V0.toFixed(2)}) / ${t.toFixed(2)}</p>
                            <hr style="border-color: #ddd; margin: 5px 0;">
                            <p style="font-size: 1.2em; color: #4CAF50; font-weight: bold;">a = ${A_calc.toFixed(2)} m/s²</p>
                        `;
                        
                        this.aceleracaoInput.value = A_calc.toFixed(2);
                        A_demo = A_calc;
                    }
                    
                    this.resultadoDiv.innerHTML = output;

                    // Inicia a demonstração visual, garantindo que os valores usados na demo sejam os calculados
                    this.iniciarDemonstracaoCalculo(S0_demo, V0_demo, A_demo, T_demo);


                } catch (error) {
                    this.resultadoDiv.innerHTML = `<span style="color: red; font-weight: bold;">ERRO:</span> ${error.message}`;
                    this.actionButton.disabled = false;
                }
            }
            
            // --- CONFIGURAÇÕES VISUAIS ---

            redimensionarCanvas() {
                // Mantém o tamanho da grade no redimensionamento da janela
                this.planoCartesiano.style.backgroundSize = `${this.TAMANHO_CELULA}px ${this.TAMANHO_CELULA}px`;

                this.corpoData.posicaoInicial = this._parseInput(this.sStartInput) || 0;
                this.atualizaPosicaoCorpo(this.corpoData.posicaoInicial); 
            }
            
            configurarInputs(modo) {
                const allGroups = ['s-start', 's-end', 'v0', 'v-end', 'a', 't-end'];
                let gruposAtivos = [];
                
                allGroups.forEach(groupSelector => {
                    const groupElement = document.querySelector(`[data-input-group="${groupSelector}"]`);
                    if (groupElement) {
                        groupElement.style.display = 'none';
                    }
                });

                if (modo === 'simulacao' || modo === 'posicao' || modo === 'velocidade') {
                    // S₀, V₀, a, t
                    gruposAtivos = ['s-start', 'v0', 'a', 't-end'];
                    
                } else if (modo === 'aceleracao') {
                    // S₀, V₀, V, t
                    gruposAtivos = ['s-start', 'v0', 'v-end', 't-end'];
                }
                
                gruposAtivos.forEach(groupSelector => {
                    const groupElement = document.querySelector(`[data-input-group="${groupSelector}"]`);
                    if (groupElement) {
                        groupElement.style.display = 'flex';
                    }
                });
                
                const sStartLabel = document.querySelector('[data-input-group="s-start"] .label');
                if (sStartLabel) {
                    sStartLabel.textContent = `Posição Inicial (S₀) (m)${modo === 'simulacao' ? ' - ARRASTE A BOLA' : ''}`;
                }
            }
        }

        // Cria a instância global
        const calculadoraMRUV = new CalculadoraMRUV();
        window.addEventListener('resize', () => calculadoraMRUV.redimensionarCanvas());
        document.addEventListener('DOMContentLoaded', () => {
            calculadoraMRUV.setMode('simulacao');
            calculadoraMRUV.redimensionarCanvas();
        });
    </script>
</body>
</html>